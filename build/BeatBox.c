/* BeatBox.c generated by valac 0.11.6, the Vala compiler
 * generated from BeatBox.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>
#include <unique/unique.h>
#include <stdio.h>


#define BEAT_BOX_TYPE_BEATBOX (beat_box_beatbox_get_type ())
#define BEAT_BOX_BEATBOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_BEATBOX, BeatBoxBeatbox))
#define BEAT_BOX_BEATBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_BEATBOX, BeatBoxBeatboxClass))
#define BEAT_BOX_IS_BEATBOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_BEATBOX))
#define BEAT_BOX_IS_BEATBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_BEATBOX))
#define BEAT_BOX_BEATBOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_BEATBOX, BeatBoxBeatboxClass))

typedef struct _BeatBoxBeatbox BeatBoxBeatbox;
typedef struct _BeatBoxBeatboxClass BeatBoxBeatboxClass;
typedef struct _BeatBoxBeatboxPrivate BeatBoxBeatboxPrivate;

#define BEAT_BOX_TYPE_LIBRARY_WINDOW (beat_box_library_window_get_type ())
#define BEAT_BOX_LIBRARY_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_LIBRARY_WINDOW, BeatBoxLibraryWindow))
#define BEAT_BOX_LIBRARY_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_LIBRARY_WINDOW, BeatBoxLibraryWindowClass))
#define BEAT_BOX_IS_LIBRARY_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_LIBRARY_WINDOW))
#define BEAT_BOX_IS_LIBRARY_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_LIBRARY_WINDOW))
#define BEAT_BOX_LIBRARY_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_LIBRARY_WINDOW, BeatBoxLibraryWindowClass))

typedef struct _BeatBoxLibraryWindow BeatBoxLibraryWindow;
typedef struct _BeatBoxLibraryWindowClass BeatBoxLibraryWindowClass;

#define BEAT_BOX_TYPE_DATA_BASE_MANAGER (beat_box_data_base_manager_get_type ())
#define BEAT_BOX_DATA_BASE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_DATA_BASE_MANAGER, BeatBoxDataBaseManager))
#define BEAT_BOX_DATA_BASE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_DATA_BASE_MANAGER, BeatBoxDataBaseManagerClass))
#define BEAT_BOX_IS_DATA_BASE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_DATA_BASE_MANAGER))
#define BEAT_BOX_IS_DATA_BASE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_DATA_BASE_MANAGER))
#define BEAT_BOX_DATA_BASE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_DATA_BASE_MANAGER, BeatBoxDataBaseManagerClass))

typedef struct _BeatBoxDataBaseManager BeatBoxDataBaseManager;
typedef struct _BeatBoxDataBaseManagerClass BeatBoxDataBaseManagerClass;

#define BEAT_BOX_TYPE_STREAM_PLAYER (beat_box_stream_player_get_type ())
#define BEAT_BOX_STREAM_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_STREAM_PLAYER, BeatBoxStreamPlayer))
#define BEAT_BOX_STREAM_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_STREAM_PLAYER, BeatBoxStreamPlayerClass))
#define BEAT_BOX_IS_STREAM_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_STREAM_PLAYER))
#define BEAT_BOX_IS_STREAM_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_STREAM_PLAYER))
#define BEAT_BOX_STREAM_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_STREAM_PLAYER, BeatBoxStreamPlayerClass))

typedef struct _BeatBoxStreamPlayer BeatBoxStreamPlayer;
typedef struct _BeatBoxStreamPlayerClass BeatBoxStreamPlayerClass;
#define _unique_message_data_free0(var) ((var == NULL) ? NULL : (var = (unique_message_data_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gtk_icon_source_free0(var) ((var == NULL) ? NULL : (var = (gtk_icon_source_free (var), NULL)))
#define _gtk_icon_set_unref0(var) ((var == NULL) ? NULL : (var = (gtk_icon_set_unref (var), NULL)))

struct _BeatBoxBeatbox {
	GObject parent_instance;
	BeatBoxBeatboxPrivate * priv;
};

struct _BeatBoxBeatboxClass {
	GObjectClass parent_class;
};


static gpointer beat_box_beatbox_parent_class = NULL;
static BeatBoxLibraryWindow* beat_box_beatbox__program;
static BeatBoxLibraryWindow* beat_box_beatbox__program = NULL;
static BeatBoxDataBaseManager* beat_box_beatbox_dbm;
static BeatBoxDataBaseManager* beat_box_beatbox_dbm = NULL;
static BeatBoxStreamPlayer* beat_box_beatbox__player;
static BeatBoxStreamPlayer* beat_box_beatbox__player = NULL;

GType beat_box_beatbox_get_type (void) G_GNUC_CONST;
enum  {
	BEAT_BOX_BEATBOX_DUMMY_PROPERTY
};
GType beat_box_library_window_get_type (void) G_GNUC_CONST;
GType beat_box_data_base_manager_get_type (void) G_GNUC_CONST;
GType beat_box_stream_player_get_type (void) G_GNUC_CONST;
gint beat_box_beatbox_main (gchar** args, int args_length1);
void beat_box_beatbox_add_stock_images (void);
BeatBoxStreamPlayer* beat_box_stream_player_new (gchar** args, int args_length1);
BeatBoxStreamPlayer* beat_box_stream_player_construct (GType object_type, gchar** args, int args_length1);
BeatBoxDataBaseManager* beat_box_data_base_manager_new (gboolean write, gboolean create);
BeatBoxDataBaseManager* beat_box_data_base_manager_construct (GType object_type, gboolean write, gboolean create);
void beat_box_data_base_manager_load_db (BeatBoxDataBaseManager* self);
BeatBoxLibraryWindow* beat_box_library_window_new (BeatBoxDataBaseManager* dbm, BeatBoxStreamPlayer* player);
BeatBoxLibraryWindow* beat_box_library_window_construct (GType object_type, BeatBoxDataBaseManager* dbm, BeatBoxStreamPlayer* player);
BeatBoxBeatbox* beat_box_beatbox_new (void);
BeatBoxBeatbox* beat_box_beatbox_construct (GType object_type);
static void beat_box_beatbox_finalize (GObject* obj);

static const GtkStockItem BEAT_BOX_BEATBOX_stock_items[14] = {{"beatbox", NULL, 0, (guint) 0}, {"folder-music", NULL, 0, (guint) 0}, {"media-audio", NULL, 0, (guint) 0}, {"emblem-urgent", NULL, 0, (guint) 0}, {"playlist", "_Playlist", 0, (guint) 0}, {"playlist-automatic", "_Smart Playlist", 0, (guint) 0}, {"starred", NULL, 0, (guint) 0}, {"not-starred", NULL, 0, (guint) 0}, {"audio-volume-high", NULL, 0, (guint) 0}, {"media-playlist-repeat-active-symbolic", NULL, 0, (guint) 0}, {"media-playlist-repeat-symbolic", NULL, 0, (guint) 0}, {"media-playlist-shuffle-active-symbolic", NULL, 0, (guint) 0}, {"media-playlist-shuffle-symbolic", NULL, 0, (guint) 0}, {"help-info", NULL, 0, (guint) 0}};

gint beat_box_beatbox_main (gchar** args, int args_length1) {
	gint result = 0;
	UniqueApp* _tmp0_ = NULL;
	UniqueApp* app;
	gboolean _tmp1_;
	gtk_init (&args_length1, &args);
	_tmp0_ = unique_app_new ("org.elementary.beatbox", NULL);
	app = _tmp0_;
	if ((g_object_get (app, "is-running", &_tmp1_, NULL), _tmp1_)) {
		UniqueCommand command;
		UniqueMessageData* _tmp2_ = NULL;
		UniqueMessageData* message;
		command = UNIQUE_ACTIVATE;
		_tmp2_ = unique_message_data_new ();
		message = _tmp2_;
		unique_app_send_message (app, (gint) command, message);
		_unique_message_data_free0 (message);
	} else {
		BeatBoxStreamPlayer* _tmp3_ = NULL;
		BeatBoxStreamPlayer* _tmp4_;
		BeatBoxDataBaseManager* _tmp5_ = NULL;
		BeatBoxDataBaseManager* _tmp6_;
		BeatBoxLibraryWindow* _tmp7_ = NULL;
		BeatBoxLibraryWindow* _tmp8_;
		gdk_threads_init ();
		beat_box_beatbox_add_stock_images ();
		fprintf (stdout, "Creating streamplayer\n");
		_tmp3_ = beat_box_stream_player_new (args, args_length1);
		_tmp4_ = _tmp3_;
		_g_object_unref0 (beat_box_beatbox__player);
		beat_box_beatbox__player = _tmp4_;
		fprintf (stdout, "Creating database manager\n");
		_tmp5_ = beat_box_data_base_manager_new (TRUE, TRUE);
		_tmp6_ = _tmp5_;
		_g_object_unref0 (beat_box_beatbox_dbm);
		beat_box_beatbox_dbm = _tmp6_;
		fprintf (stdout, "Loading database\n");
		beat_box_data_base_manager_load_db (beat_box_beatbox_dbm);
		_tmp7_ = beat_box_library_window_new (beat_box_beatbox_dbm, beat_box_beatbox__player);
		_tmp8_ = g_object_ref_sink (_tmp7_);
		_g_object_unref0 (beat_box_beatbox__program);
		beat_box_beatbox__program = _tmp8_;
		unique_app_watch_window (app, (GtkWindow*) beat_box_beatbox__program);
		gtk_main ();
	}
	result = 1;
	_g_object_unref0 (app);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return beat_box_beatbox_main (argv, argc);
}


void beat_box_beatbox_add_stock_images (void) {
	GtkIconFactory* _tmp0_ = NULL;
	GtkIconFactory* iFactory;
	_tmp0_ = gtk_icon_factory_new ();
	iFactory = _tmp0_;
	{
		GtkStockItem* stockItem_collection;
		int stockItem_collection_length1;
		int stockItem_it;
		stockItem_collection = BEAT_BOX_BEATBOX_stock_items;
		stockItem_collection_length1 = G_N_ELEMENTS (BEAT_BOX_BEATBOX_stock_items);
		for (stockItem_it = 0; stockItem_it < G_N_ELEMENTS (BEAT_BOX_BEATBOX_stock_items); stockItem_it = stockItem_it + 1) {
			GtkStockItem stockItem;
			stockItem = stockItem_collection[stockItem_it];
			{
				GtkIconSet* _tmp1_ = NULL;
				GtkIconSet* iconSet;
				GtkIconSource* _tmp2_ = NULL;
				GtkIconSource* iconSource;
				_tmp1_ = gtk_icon_set_new ();
				iconSet = _tmp1_;
				_tmp2_ = gtk_icon_source_new ();
				iconSource = _tmp2_;
				if (stockItem.translation_domain != NULL) {
					gtk_icon_source_set_icon_name (iconSource, stockItem.translation_domain);
					stockItem.translation_domain = NULL;
					gtk_icon_set_add_source (iconSet, iconSource);
				}
				gtk_icon_source_set_icon_name (iconSource, stockItem.stock_id);
				gtk_icon_set_add_source (iconSet, iconSource);
				gtk_icon_factory_add (iFactory, stockItem.stock_id, iconSet);
				_gtk_icon_source_free0 (iconSource);
				_gtk_icon_set_unref0 (iconSet);
			}
		}
	}
	gtk_stock_add (BEAT_BOX_BEATBOX_stock_items, G_N_ELEMENTS (BEAT_BOX_BEATBOX_stock_items));
	gtk_icon_factory_add_default (iFactory);
	_g_object_unref0 (iFactory);
}


BeatBoxBeatbox* beat_box_beatbox_construct (GType object_type) {
	BeatBoxBeatbox * self = NULL;
	self = (BeatBoxBeatbox*) g_object_new (object_type, NULL);
	return self;
}


BeatBoxBeatbox* beat_box_beatbox_new (void) {
	return beat_box_beatbox_construct (BEAT_BOX_TYPE_BEATBOX);
}


static void beat_box_beatbox_class_init (BeatBoxBeatboxClass * klass) {
	beat_box_beatbox_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = beat_box_beatbox_finalize;
}


static void beat_box_beatbox_instance_init (BeatBoxBeatbox * self) {
}


static void beat_box_beatbox_finalize (GObject* obj) {
	BeatBoxBeatbox * self;
	self = BEAT_BOX_BEATBOX (obj);
	G_OBJECT_CLASS (beat_box_beatbox_parent_class)->finalize (obj);
}


/** Runs the program
 * 
 */
GType beat_box_beatbox_get_type (void) {
	static volatile gsize beat_box_beatbox_type_id__volatile = 0;
	if (g_once_init_enter (&beat_box_beatbox_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BeatBoxBeatboxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beat_box_beatbox_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BeatBoxBeatbox), 0, (GInstanceInitFunc) beat_box_beatbox_instance_init, NULL };
		GType beat_box_beatbox_type_id;
		beat_box_beatbox_type_id = g_type_register_static (G_TYPE_OBJECT, "BeatBoxBeatbox", &g_define_type_info, 0);
		g_once_init_leave (&beat_box_beatbox_type_id__volatile, beat_box_beatbox_type_id);
	}
	return beat_box_beatbox_type_id__volatile;
}



