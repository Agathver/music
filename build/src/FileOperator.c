/* FileOperator.c generated by valac 0.11.6, the Vala compiler
 * generated from FileOperator.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <tag_c.h>
#include <time.h>
#include <gdk-pixbuf/gdk-pixdata.h>


#define BEAT_BOX_TYPE_FILE_OPERATOR (beat_box_file_operator_get_type ())
#define BEAT_BOX_FILE_OPERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperator))
#define BEAT_BOX_FILE_OPERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperatorClass))
#define BEAT_BOX_IS_FILE_OPERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_FILE_OPERATOR))
#define BEAT_BOX_IS_FILE_OPERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_FILE_OPERATOR))
#define BEAT_BOX_FILE_OPERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperatorClass))

typedef struct _BeatBoxFileOperator BeatBoxFileOperator;
typedef struct _BeatBoxFileOperatorClass BeatBoxFileOperatorClass;
typedef struct _BeatBoxFileOperatorPrivate BeatBoxFileOperatorPrivate;

#define BEAT_BOX_TYPE_LIBRARY_MANAGER (beat_box_library_manager_get_type ())
#define BEAT_BOX_LIBRARY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_LIBRARY_MANAGER, BeatBoxLibraryManager))
#define BEAT_BOX_LIBRARY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_LIBRARY_MANAGER, BeatBoxLibraryManagerClass))
#define BEAT_BOX_IS_LIBRARY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_LIBRARY_MANAGER))
#define BEAT_BOX_IS_LIBRARY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_LIBRARY_MANAGER))
#define BEAT_BOX_LIBRARY_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_LIBRARY_MANAGER, BeatBoxLibraryManagerClass))

typedef struct _BeatBoxLibraryManager BeatBoxLibraryManager;
typedef struct _BeatBoxLibraryManagerClass BeatBoxLibraryManagerClass;

#define BEAT_BOX_TYPE_SETTINGS (beat_box_settings_get_type ())
#define BEAT_BOX_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettings))
#define BEAT_BOX_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettingsClass))
#define BEAT_BOX_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_SETTINGS))
#define BEAT_BOX_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_SETTINGS))
#define BEAT_BOX_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettingsClass))

typedef struct _BeatBoxSettings BeatBoxSettings;
typedef struct _BeatBoxSettingsClass BeatBoxSettingsClass;

#define BEAT_BOX_TYPE_SONG (beat_box_song_get_type ())
#define BEAT_BOX_SONG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_SONG, BeatBoxSong))
#define BEAT_BOX_SONG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_SONG, BeatBoxSongClass))
#define BEAT_BOX_IS_SONG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_SONG))
#define BEAT_BOX_IS_SONG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_SONG))
#define BEAT_BOX_SONG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_SONG, BeatBoxSongClass))

typedef struct _BeatBoxSong BeatBoxSong;
typedef struct _BeatBoxSongClass BeatBoxSongClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _taglib_file_free0(var) ((var == NULL) ? NULL : (var = (taglib_file_free (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

struct _BeatBoxFileOperator {
	GObject parent_instance;
	BeatBoxFileOperatorPrivate * priv;
};

struct _BeatBoxFileOperatorClass {
	GObjectClass parent_class;
};

struct _BeatBoxFileOperatorPrivate {
	BeatBoxLibraryManager* lm;
	BeatBoxSettings* settings;
	gboolean inThread;
	GeeLinkedList* toSave;
	gint index;
	gint item_count;
};


static gpointer beat_box_file_operator_parent_class = NULL;

GType beat_box_file_operator_get_type (void) G_GNUC_CONST;
GType beat_box_library_manager_get_type (void) G_GNUC_CONST;
GType beat_box_settings_get_type (void) G_GNUC_CONST;
GType beat_box_song_get_type (void) G_GNUC_CONST;
#define BEAT_BOX_FILE_OPERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperatorPrivate))
enum  {
	BEAT_BOX_FILE_OPERATOR_DUMMY_PROPERTY
};
BeatBoxFileOperator* beat_box_file_operator_new (BeatBoxLibraryManager* lmm, BeatBoxSettings* sett);
BeatBoxFileOperator* beat_box_file_operator_construct (GType object_type, BeatBoxLibraryManager* lmm, BeatBoxSettings* sett);
void beat_box_file_operator_resetProgress (BeatBoxFileOperator* self, gint items);
static gboolean beat_box_file_operator_is_valid_file_type (BeatBoxFileOperator* self, const gchar* type);
gint beat_box_file_operator_count_music_files (BeatBoxFileOperator* self, GFile* music_folder);
void beat_box_file_operator_get_music_files (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** songs, GeeLinkedList** not_imported);
BeatBoxSong* beat_box_file_operator_import_song (BeatBoxFileOperator* self, const gchar* file_path);
void beat_box_file_operator_rescan_music (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** current_song_paths, GeeLinkedList** not_imported, GeeLinkedList** new_songs);
BeatBoxSong* beat_box_song_new (const gchar* file);
BeatBoxSong* beat_box_song_construct (GType object_type, const gchar* file);
void beat_box_song_set_title (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_artist (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_album (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_genre (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_comment (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_year (BeatBoxSong* self, gint value);
void beat_box_song_set_track (BeatBoxSong* self, gint value);
void beat_box_song_set_bitrate (BeatBoxSong* self, gint value);
void beat_box_song_set_length (BeatBoxSong* self, gint value);
void beat_box_song_set_samplerate (BeatBoxSong* self, gint value);
void beat_box_song_set_date_added (BeatBoxSong* self, gint value);
const gchar* beat_box_song_get_title (BeatBoxSong* self);
const gchar* beat_box_song_get_artist (BeatBoxSong* self);
static gboolean beat_box_file_operator_is_image_file_type (BeatBoxFileOperator* self, const gchar* type);
gchar* beat_box_file_operator_get_folder (const gchar* file);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
gchar* beat_box_file_operator_find_album (BeatBoxFileOperator* self, BeatBoxSong* s);
const gchar* beat_box_song_get_file (BeatBoxSong* self);
const gchar* beat_box_song_get_album (BeatBoxSong* self);
GdkPixbuf* beat_box_file_operator_save_album (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri);
gchar* beat_box_file_operator_find_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s);
GdkPixbuf* beat_box_file_operator_save_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri);
void beat_box_file_operator_save_songs (BeatBoxFileOperator* self, GeeCollection* to_save);
void* beat_box_file_operator_save_song_thread (BeatBoxFileOperator* self);
static gpointer _beat_box_file_operator_save_song_thread_gthread_func (gpointer self);
const gchar* beat_box_song_get_genre (BeatBoxSong* self);
const gchar* beat_box_song_get_comment (BeatBoxSong* self);
gint beat_box_song_get_year (BeatBoxSong* self);
gint beat_box_song_get_track (BeatBoxSong* self);
gboolean beat_box_settings_getUpdateFolderHierarchy (BeatBoxSettings* self);
void beat_box_file_operator_update_file_hierarchy (BeatBoxFileOperator* self, BeatBoxSong* s, gboolean delete_old);
gchar* beat_box_settings_getMusicFolder (BeatBoxSettings* self);
void beat_box_song_set_file (BeatBoxSong* self, const gchar* value);
void beat_box_file_operator_remove_songs (BeatBoxFileOperator* self, GeeCollection* toRemove);
static void g_cclosure_user_marshal_VOID__STRING_DOUBLE (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void beat_box_file_operator_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


BeatBoxFileOperator* beat_box_file_operator_construct (GType object_type, BeatBoxLibraryManager* lmm, BeatBoxSettings* sett) {
	BeatBoxFileOperator * self = NULL;
	BeatBoxLibraryManager* _tmp0_;
	BeatBoxLibraryManager* _tmp1_;
	BeatBoxSettings* _tmp2_;
	BeatBoxSettings* _tmp3_;
	GeeLinkedList* _tmp4_ = NULL;
	GeeLinkedList* _tmp5_;
	g_return_val_if_fail (lmm != NULL, NULL);
	g_return_val_if_fail (sett != NULL, NULL);
	self = (BeatBoxFileOperator*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (lmm);
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->lm);
	self->priv->lm = _tmp1_;
	_tmp2_ = _g_object_ref0 (sett);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp3_;
	self->priv->inThread = FALSE;
	_tmp4_ = gee_linked_list_new (BEAT_BOX_TYPE_SONG, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_tmp5_ = _tmp4_;
	_g_object_unref0 (self->priv->toSave);
	self->priv->toSave = _tmp5_;
	return self;
}


BeatBoxFileOperator* beat_box_file_operator_new (BeatBoxLibraryManager* lmm, BeatBoxSettings* sett) {
	return beat_box_file_operator_construct (BEAT_BOX_TYPE_FILE_OPERATOR, lmm, sett);
}


void beat_box_file_operator_resetProgress (BeatBoxFileOperator* self, gint items) {
	g_return_if_fail (self != NULL);
	self->priv->index = 0;
	self->priv->item_count = items;
}


static gboolean beat_box_file_operator_is_valid_file_type (BeatBoxFileOperator* self, const gchar* type) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gboolean _tmp7_;
	gboolean _tmp8_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (type != NULL, FALSE);
	_tmp5_ = g_utf8_strdown (type, (gssize) (-1));
	_tmp6_ = _tmp5_;
	_tmp7_ = g_str_has_suffix (_tmp6_, ".mp3");
	if ((_tmp8_ = _tmp7_, _g_free0 (_tmp6_), _tmp8_)) {
		_tmp4_ = TRUE;
	} else {
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		gboolean _tmp11_;
		_tmp9_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp10_ = _tmp9_;
		_tmp11_ = g_str_has_suffix (_tmp10_, ".m4a");
		_tmp4_ = _tmp11_;
		_g_free0 (_tmp10_);
	}
	if (_tmp4_) {
		_tmp3_ = TRUE;
	} else {
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_;
		gboolean _tmp14_;
		_tmp12_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp13_ = _tmp12_;
		_tmp14_ = g_str_has_suffix (_tmp13_, ".wma");
		_tmp3_ = _tmp14_;
		_g_free0 (_tmp13_);
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_;
		gboolean _tmp17_;
		_tmp15_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp16_ = _tmp15_;
		_tmp17_ = g_str_has_suffix (_tmp16_, ".ogg");
		_tmp2_ = _tmp17_;
		_g_free0 (_tmp16_);
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_;
		gboolean _tmp20_;
		_tmp18_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp19_ = _tmp18_;
		_tmp20_ = g_str_has_suffix (_tmp19_, ".flac");
		_tmp1_ = _tmp20_;
		_g_free0 (_tmp19_);
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_;
		gboolean _tmp23_;
		_tmp21_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp22_ = _tmp21_;
		_tmp23_ = g_str_has_suffix (_tmp22_, ".mp4");
		_tmp0_ = _tmp23_;
		_g_free0 (_tmp22_);
	}
	result = _tmp0_;
	return result;
}


gint beat_box_file_operator_count_music_files (BeatBoxFileOperator* self, GFile* music_folder) {
	gint result = 0;
	GFileInfo* file_info;
	GFileEnumerator* _tmp0_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (music_folder != NULL, 0);
	file_info = NULL;
	_tmp0_ = g_file_enumerate_children (music_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch30_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp1_ = NULL;
		GFileInfo* _tmp2_;
		GFileInfo* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* file_path;
		gboolean _tmp9_ = FALSE;
		GFileType _tmp10_;
		_tmp1_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch30_g_error;
		}
		_tmp3_ = _tmp2_;
		_g_object_unref0 (file_info);
		file_info = _tmp3_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp4_ = g_file_get_path (music_folder);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_strconcat (_tmp5_, "/", NULL);
		_tmp7_ = g_file_info_get_name (file_info);
		file_path = (_tmp8_ = g_strconcat (_tmp6_, _tmp7_, NULL), _g_free0 (_tmp6_), _g_free0 (_tmp5_), _tmp8_);
		_tmp10_ = g_file_info_get_file_type (file_info);
		if (_tmp10_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp11_ = NULL;
			gboolean _tmp12_;
			_tmp11_ = g_file_info_get_name (file_info);
			_tmp12_ = beat_box_file_operator_is_valid_file_type (self, _tmp11_);
			_tmp9_ = _tmp12_;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			self->priv->index++;
		} else {
			GFileType _tmp13_;
			_tmp13_ = g_file_info_get_file_type (file_info);
			if (_tmp13_ == G_FILE_TYPE_DIRECTORY) {
				GFile* _tmp14_ = NULL;
				GFile* _tmp15_;
				_tmp14_ = g_file_new_for_path (file_path);
				_tmp15_ = _tmp14_;
				beat_box_file_operator_count_music_files (self, _tmp15_);
				_g_object_unref0 (_tmp15_);
			}
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally30;
	__catch30_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not pre-scan music folder. Progress percentage may be off: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally30:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = self->priv->index;
	_g_object_unref0 (file_info);
	return result;
}


void beat_box_file_operator_get_music_files (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** songs, GeeLinkedList** not_imported) {
	GFileInfo* file_info;
	GFileEnumerator* _tmp0_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (music_folder != NULL);
	g_return_if_fail (songs != NULL);
	g_return_if_fail (not_imported != NULL);
	file_info = NULL;
	_tmp0_ = g_file_enumerate_children (music_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch31_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp1_ = NULL;
		GFileInfo* _tmp2_;
		GFileInfo* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* file_path;
		gboolean _tmp9_ = FALSE;
		GFileType _tmp10_;
		_tmp1_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch31_g_error;
		}
		_tmp3_ = _tmp2_;
		_g_object_unref0 (file_info);
		file_info = _tmp3_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp4_ = g_file_get_path (music_folder);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_strconcat (_tmp5_, "/", NULL);
		_tmp7_ = g_file_info_get_name (file_info);
		file_path = (_tmp8_ = g_strconcat (_tmp6_, _tmp7_, NULL), _g_free0 (_tmp6_), _g_free0 (_tmp5_), _tmp8_);
		_tmp10_ = g_file_info_get_file_type (file_info);
		if (_tmp10_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp11_ = NULL;
			gboolean _tmp12_;
			_tmp11_ = g_file_info_get_name (file_info);
			_tmp12_ = beat_box_file_operator_is_valid_file_type (self, _tmp11_);
			_tmp9_ = _tmp12_;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			BeatBoxSong* _tmp13_ = NULL;
			BeatBoxSong* s;
			self->priv->index = self->priv->index + 1;
			g_signal_emit_by_name (self, "fo-progress", NULL, ((gdouble) ((gdouble) self->priv->index)) / ((gdouble) self->priv->item_count));
			_tmp13_ = beat_box_file_operator_import_song (self, file_path);
			s = _tmp13_;
			if (s != NULL) {
				gee_abstract_collection_add ((GeeAbstractCollection*) (*songs), s);
			} else {
				gee_abstract_collection_add ((GeeAbstractCollection*) (*not_imported), file_path);
			}
			_g_object_unref0 (s);
		} else {
			GFileType _tmp14_;
			_tmp14_ = g_file_info_get_file_type (file_info);
			if (_tmp14_ == G_FILE_TYPE_DIRECTORY) {
				GFile* _tmp15_ = NULL;
				GFile* _tmp16_;
				_tmp15_ = g_file_new_for_path (file_path);
				_tmp16_ = _tmp15_;
				beat_box_file_operator_get_music_files (self, _tmp16_, songs, not_imported);
				_g_object_unref0 (_tmp16_);
			}
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally31;
	__catch31_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not get music: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally31:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (file_info);
}


/** rescans the music folder to update the db to the folder situation.
 * If song is in folder, and in db, re-add
 * If song is not in folder and in db,remove
 * If song is in both, do nothing.
 * @param music_folder The folder to rescan
 * @param current_song_paths Paths of files already in db. once file
 * is re-added, set string to "ADDED". at end, remove all songs that
 * are not re-added.
 * @return file paths of songs no longer available. TODO: should out that
 */
void beat_box_file_operator_rescan_music (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** current_song_paths, GeeLinkedList** not_imported, GeeLinkedList** new_songs) {
	GFileInfo* file_info;
	gint songs_added;
	GFileEnumerator* _tmp0_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (music_folder != NULL);
	g_return_if_fail (current_song_paths != NULL);
	g_return_if_fail (not_imported != NULL);
	g_return_if_fail (new_songs != NULL);
	file_info = NULL;
	songs_added = 0;
	_tmp0_ = g_file_enumerate_children (music_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch32_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp1_ = NULL;
		GFileInfo* _tmp2_;
		GFileInfo* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* file_path;
		gboolean _tmp9_ = FALSE;
		GFileType _tmp10_;
		_tmp1_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch32_g_error;
		}
		_tmp3_ = _tmp2_;
		_g_object_unref0 (file_info);
		file_info = _tmp3_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp4_ = g_file_get_path (music_folder);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_strconcat (_tmp5_, "/", NULL);
		_tmp7_ = g_file_info_get_name (file_info);
		file_path = (_tmp8_ = g_strconcat (_tmp6_, _tmp7_, NULL), _g_free0 (_tmp6_), _g_free0 (_tmp5_), _tmp8_);
		g_signal_emit_by_name (self, "fo-progress", NULL, ((gdouble) ((gdouble) self->priv->index)) / ((gdouble) self->priv->item_count));
		_tmp10_ = g_file_info_get_file_type (file_info);
		if (_tmp10_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp11_ = NULL;
			gboolean _tmp12_;
			_tmp11_ = g_file_info_get_name (file_info);
			_tmp12_ = beat_box_file_operator_is_valid_file_type (self, _tmp11_);
			_tmp9_ = _tmp12_;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			gboolean _tmp13_;
			_tmp13_ = gee_abstract_collection_contains ((GeeAbstractCollection*) (*current_song_paths), file_path);
			if (_tmp13_) {
				gee_abstract_collection_remove ((GeeAbstractCollection*) (*current_song_paths), file_path);
				self->priv->index = self->priv->index + 1;
			} else {
				gboolean _tmp14_;
				_tmp14_ = gee_abstract_collection_contains ((GeeAbstractCollection*) (*current_song_paths), file_path);
				if (!_tmp14_) {
					BeatBoxSong* _tmp15_ = NULL;
					BeatBoxSong* s;
					_tmp15_ = beat_box_file_operator_import_song (self, file_path);
					s = _tmp15_;
					if (s != NULL) {
						gee_abstract_collection_add ((GeeAbstractCollection*) (*new_songs), s);
					} else {
						gee_abstract_collection_add ((GeeAbstractCollection*) (*not_imported), file_path);
					}
					songs_added = songs_added + 1;
					_g_object_unref0 (s);
				}
			}
		} else {
			GFileType _tmp16_;
			_tmp16_ = g_file_info_get_file_type (file_info);
			if (_tmp16_ == G_FILE_TYPE_DIRECTORY) {
				GFile* _tmp17_ = NULL;
				GFile* _tmp18_;
				_tmp17_ = g_file_new_for_path (file_path);
				_tmp18_ = _tmp17_;
				beat_box_file_operator_rescan_music (self, _tmp18_, current_song_paths, not_imported, new_songs);
				_g_object_unref0 (_tmp18_);
			}
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally32;
	__catch32_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not rescan music folder: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally32:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (file_info);
}


BeatBoxSong* beat_box_file_operator_import_song (BeatBoxFileOperator* self, const gchar* file_path) {
	BeatBoxSong* result = NULL;
	BeatBoxSong* _tmp0_ = NULL;
	BeatBoxSong* s;
	TagLib_File* tag_file = NULL;
	TagLib_File* _tmp1_ = NULL;
	TagLib_File* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (file_path != NULL, NULL);
	_tmp0_ = beat_box_song_new (file_path);
	s = _tmp0_;
	_tmp1_ = taglib_file_new (file_path);
	_tmp2_ = _tmp1_;
	_taglib_file_free0 (tag_file);
	tag_file = _tmp2_;
	if (tag_file != NULL) {
		TagLib_Tag* _tmp5_ = NULL;
		_tmp5_ = taglib_file_tag (tag_file);
		_tmp4_ = _tmp5_ != NULL;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		const TagLib_AudioProperties* _tmp6_ = NULL;
		_tmp6_ = taglib_file_audioproperties (tag_file);
		_tmp3_ = _tmp6_ != NULL;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		TagLib_Tag* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		TagLib_Tag* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		TagLib_Tag* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		TagLib_Tag* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		TagLib_Tag* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		TagLib_Tag* _tmp17_ = NULL;
		guint _tmp18_;
		TagLib_Tag* _tmp19_ = NULL;
		guint _tmp20_;
		const TagLib_AudioProperties* _tmp21_ = NULL;
		gint _tmp22_;
		const TagLib_AudioProperties* _tmp23_ = NULL;
		gint _tmp24_;
		const TagLib_AudioProperties* _tmp25_ = NULL;
		gint _tmp26_;
		time_t _tmp27_;
		gboolean _tmp28_ = FALSE;
		const gchar* _tmp29_ = NULL;
		gboolean _tmp31_ = FALSE;
		const gchar* _tmp32_ = NULL;
		_tmp7_ = taglib_file_tag (tag_file);
		_tmp8_ = taglib_tag_title (_tmp7_);
		beat_box_song_set_title (s, _tmp8_);
		_tmp9_ = taglib_file_tag (tag_file);
		_tmp10_ = taglib_tag_artist (_tmp9_);
		beat_box_song_set_artist (s, _tmp10_);
		_tmp11_ = taglib_file_tag (tag_file);
		_tmp12_ = taglib_tag_album (_tmp11_);
		beat_box_song_set_album (s, _tmp12_);
		_tmp13_ = taglib_file_tag (tag_file);
		_tmp14_ = taglib_tag_genre (_tmp13_);
		beat_box_song_set_genre (s, _tmp14_);
		_tmp15_ = taglib_file_tag (tag_file);
		_tmp16_ = taglib_tag_comment (_tmp15_);
		beat_box_song_set_comment (s, _tmp16_);
		_tmp17_ = taglib_file_tag (tag_file);
		_tmp18_ = taglib_tag_year (_tmp17_);
		beat_box_song_set_year (s, (gint) _tmp18_);
		_tmp19_ = taglib_file_tag (tag_file);
		_tmp20_ = taglib_tag_track (_tmp19_);
		beat_box_song_set_track (s, (gint) _tmp20_);
		_tmp21_ = taglib_file_audioproperties (tag_file);
		_tmp22_ = taglib_audioproperties_bitrate (_tmp21_);
		beat_box_song_set_bitrate (s, _tmp22_);
		_tmp23_ = taglib_file_audioproperties (tag_file);
		_tmp24_ = taglib_audioproperties_length (_tmp23_);
		beat_box_song_set_length (s, _tmp24_);
		_tmp25_ = taglib_file_audioproperties (tag_file);
		_tmp26_ = taglib_audioproperties_samplerate (_tmp25_);
		beat_box_song_set_samplerate (s, _tmp26_);
		_tmp27_ = time (NULL);
		beat_box_song_set_date_added (s, (gint) _tmp27_);
		__finally33:
		_tmp29_ = beat_box_song_get_title (s);
		if (_tmp29_ == NULL) {
			_tmp28_ = TRUE;
		} else {
			const gchar* _tmp30_ = NULL;
			_tmp30_ = beat_box_song_get_title (s);
			_tmp28_ = g_strcmp0 (_tmp30_, "") == 0;
		}
		if (_tmp28_) {
			beat_box_song_set_title (s, "Unkown");
		}
		_tmp32_ = beat_box_song_get_artist (s);
		if (_tmp32_ == NULL) {
			_tmp31_ = TRUE;
		} else {
			const gchar* _tmp33_ = NULL;
			_tmp33_ = beat_box_song_get_artist (s);
			_tmp31_ = g_strcmp0 (_tmp33_, "") == 0;
		}
		if (_tmp31_) {
			beat_box_song_set_artist (s, "Unkown");
		}
		if (_inner_error_ != NULL) {
			_taglib_file_free0 (tag_file);
			_g_object_unref0 (s);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	} else {
		result = NULL;
		_taglib_file_free0 (tag_file);
		_g_object_unref0 (s);
		return result;
	}
	result = s;
	_taglib_file_free0 (tag_file);
	return result;
}


static gboolean beat_box_file_operator_is_image_file_type (BeatBoxFileOperator* self, const gchar* type) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (type != NULL, FALSE);
	_tmp1_ = g_str_has_suffix (type, ".jpg");
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp2_;
		_tmp2_ = g_str_has_suffix (type, ".png");
		_tmp0_ = _tmp2_;
	}
	result = _tmp0_;
	return result;
}


static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


gchar* beat_box_file_operator_get_folder (const gchar* file) {
	gchar* result = NULL;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** paths;
	gint paths_length1;
	gint _paths_size_;
	gboolean _tmp2_;
	gchar* _tmp4_;
	gchar* folder_string;
	g_return_val_if_fail (file != NULL, NULL);
	_tmp1_ = _tmp0_ = g_strsplit (file, "/", 0);
	paths = _tmp1_;
	paths_length1 = _vala_array_length (_tmp0_);
	_paths_size_ = _vala_array_length (_tmp0_);
	_tmp2_ = g_str_has_suffix (file, "/");
	if (!_tmp2_) {
		gchar* _tmp3_;
		_tmp3_ = g_strdup (" ");
		_vala_array_add1 (&paths, &paths_length1, &_paths_size_, _tmp3_);
	}
	_tmp4_ = g_strdup ("");
	folder_string = _tmp4_;
	{
		gint index;
		index = 0;
		{
			gboolean _tmp5_;
			_tmp5_ = TRUE;
			while (TRUE) {
				gchar* _tmp6_;
				gchar* _tmp7_;
				if (!_tmp5_) {
					index = index + 1;
				}
				_tmp5_ = FALSE;
				if (!(index < (paths_length1 - 2))) {
					break;
				}
				_tmp6_ = g_strconcat (paths[index], "/", NULL);
				_tmp7_ = g_strconcat (folder_string, _tmp6_, NULL);
				_g_free0 (folder_string);
				folder_string = _tmp7_;
				_g_free0 (_tmp6_);
			}
		}
	}
	result = folder_string;
	paths = (_vala_array_free (paths, paths_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


gchar* beat_box_file_operator_find_album (BeatBoxFileOperator* self, BeatBoxSong* s) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* album_folder_string;
	GFile* _tmp2_ = NULL;
	GFile* album_folder;
	GFileInfo* file_info;
	GFileEnumerator* _tmp3_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	_tmp0_ = beat_box_song_get_file (s);
	_tmp1_ = beat_box_file_operator_get_folder (_tmp0_);
	album_folder_string = _tmp1_;
	_tmp2_ = g_file_new_for_path (album_folder_string);
	album_folder = _tmp2_;
	file_info = NULL;
	_tmp3_ = g_file_enumerate_children (album_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp3_;
	if (_inner_error_ != NULL) {
		goto __catch34_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp4_ = NULL;
		GFileInfo* _tmp5_;
		GFileInfo* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* _tmp9_;
		const gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		gchar* file_path;
		gboolean _tmp12_ = FALSE;
		gboolean _tmp13_ = FALSE;
		GFileType _tmp14_;
		_tmp4_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp5_ = _tmp4_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch34_g_error;
		}
		_tmp6_ = _tmp5_;
		_g_object_unref0 (file_info);
		file_info = _tmp6_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp7_ = g_file_get_path (album_folder);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_strconcat (_tmp8_, "/", NULL);
		_tmp10_ = g_file_info_get_name (file_info);
		file_path = (_tmp11_ = g_strconcat (_tmp9_, _tmp10_, NULL), _g_free0 (_tmp9_), _g_free0 (_tmp8_), _tmp11_);
		_tmp14_ = g_file_info_get_file_type (file_info);
		if (_tmp14_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp15_ = NULL;
			gboolean _tmp16_;
			_tmp15_ = g_file_info_get_name (file_info);
			_tmp16_ = beat_box_file_operator_is_image_file_type (self, _tmp15_);
			_tmp13_ = _tmp16_;
		} else {
			_tmp13_ = FALSE;
		}
		if (_tmp13_) {
			const gchar* _tmp17_ = NULL;
			const gchar* _tmp18_ = NULL;
			gboolean _tmp19_;
			_tmp17_ = g_file_info_get_name (file_info);
			_tmp18_ = beat_box_song_get_album (s);
			_tmp19_ = string_contains (_tmp17_, _tmp18_);
			_tmp12_ = _tmp19_;
		} else {
			_tmp12_ = FALSE;
		}
		if (_tmp12_) {
			result = file_path;
			_g_object_unref0 (enumerator);
			_g_object_unref0 (file_info);
			_g_object_unref0 (album_folder);
			_g_free0 (album_folder_string);
			return result;
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally34;
	__catch34_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not find album artwork: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally34:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		_g_object_unref0 (album_folder);
		_g_free0 (album_folder_string);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	_g_object_unref0 (file_info);
	_g_object_unref0 (album_folder);
	_g_free0 (album_folder_string);
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GRegex* _tmp2_ = NULL;
	GRegex* _tmp3_;
	GRegex* regex;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	_tmp0_ = g_regex_escape_string (old, -1);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_regex_new (_tmp1_, 0, 0, &_inner_error_);
	regex = (_tmp3_ = _tmp2_, _g_free0 (_tmp1_), _tmp3_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_REGEX_ERROR) {
			goto __catch36_g_regex_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
	_tmp5_ = _tmp4_;
	if (_inner_error_ != NULL) {
		_g_regex_unref0 (regex);
		if (_inner_error_->domain == G_REGEX_ERROR) {
			goto __catch36_g_regex_error;
		}
		_g_regex_unref0 (regex);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = _tmp5_;
	_g_regex_unref0 (regex);
	return result;
	_g_regex_unref0 (regex);
	goto __finally36;
	__catch36_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally36:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


GdkPixbuf* beat_box_file_operator_save_album (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* rv = NULL;
	gboolean _tmp0_ = FALSE;
	GFile* _tmp1_ = NULL;
	GFile* file;
	GFileInputStream* filestream = NULL;
	GFileInputStream* _tmp2_ = NULL;
	GFileInputStream* _tmp3_;
	GFileInputStream* _tmp4_;
	GdkPixbuf* _tmp5_ = NULL;
	GdkPixbuf* _tmp6_;
	GdkPixbuf* _tmp7_;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_;
	const gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	if (uri == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (uri, "") == 0;
	}
	if (_tmp0_) {
		result = NULL;
		_g_object_unref0 (rv);
		return result;
	}
	_tmp1_ = g_file_new_for_uri (uri);
	file = _tmp1_;
	if (file == NULL) {
		fprintf (stdout, "Could not access %s\n", uri);
		result = NULL;
		_g_object_unref0 (file);
		_g_object_unref0 (rv);
		return result;
	}
	_tmp2_ = g_file_read (file, NULL, &_inner_error_);
	_tmp3_ = _tmp2_;
	if (_inner_error_ != NULL) {
		goto __catch35_g_error;
	}
	_tmp4_ = _tmp3_;
	_g_object_unref0 (filestream);
	filestream = _tmp4_;
	_tmp5_ = gdk_pixbuf_new_from_stream ((GInputStream*) filestream, NULL, &_inner_error_);
	_tmp6_ = _tmp5_;
	if (_inner_error_ != NULL) {
		goto __catch35_g_error;
	}
	_tmp7_ = _tmp6_;
	_g_object_unref0 (rv);
	rv = _tmp7_;
	_tmp8_ = beat_box_song_get_file (s);
	_tmp9_ = beat_box_file_operator_get_folder (_tmp8_);
	_tmp10_ = _tmp9_;
	fprintf (stdout, "Saving to %s\n", _tmp10_);
	_g_free0 (_tmp10_);
	_tmp11_ = beat_box_song_get_file (s);
	_tmp12_ = beat_box_file_operator_get_folder (_tmp11_);
	_tmp13_ = _tmp12_;
	_tmp14_ = beat_box_song_get_album (s);
	_tmp15_ = string_replace (_tmp14_, "/", "_");
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strconcat (_tmp13_, _tmp16_, NULL);
	_tmp18_ = g_strconcat (_tmp17_, ".jpg", NULL);
	gdk_pixbuf_save (rv, _tmp18_, "jpeg", &_inner_error_, NULL);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp17_);
	_g_free0 (_tmp16_);
	_g_free0 (_tmp13_);
	if (_inner_error_ != NULL) {
		goto __catch35_g_error;
	}
	goto __finally35;
	__catch35_g_error:
	{
		GError * err;
		GdkPixbuf* _tmp19_;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not save album art from %s: %s\n", uri, err->message);
		_tmp19_ = NULL;
		_g_object_unref0 (rv);
		rv = _tmp19_;
		_g_error_free0 (err);
	}
	__finally35:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (filestream);
		_g_object_unref0 (file);
		_g_object_unref0 (rv);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = rv;
	_g_object_unref0 (filestream);
	_g_object_unref0 (file);
	return result;
}


gchar* beat_box_file_operator_find_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* artist_folder_string;
	GFile* _tmp5_ = NULL;
	GFile* artist_folder;
	GFileInfo* file_info;
	GFileEnumerator* _tmp6_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	_tmp0_ = beat_box_song_get_file (s);
	_tmp1_ = beat_box_file_operator_get_folder (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = beat_box_file_operator_get_folder (_tmp2_);
	artist_folder_string = (_tmp4_ = _tmp3_, _g_free0 (_tmp2_), _tmp4_);
	_tmp5_ = g_file_new_for_path (artist_folder_string);
	artist_folder = _tmp5_;
	file_info = NULL;
	_tmp6_ = g_file_enumerate_children (artist_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp6_;
	if (_inner_error_ != NULL) {
		goto __catch37_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp7_ = NULL;
		GFileInfo* _tmp8_;
		GFileInfo* _tmp9_;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		gchar* _tmp12_;
		const gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		gchar* file_path;
		gboolean _tmp15_ = FALSE;
		GFileType _tmp16_;
		_tmp7_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch37_g_error;
		}
		_tmp9_ = _tmp8_;
		_g_object_unref0 (file_info);
		file_info = _tmp9_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp10_ = g_file_get_path (artist_folder);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strconcat (_tmp11_, "/", NULL);
		_tmp13_ = g_file_info_get_name (file_info);
		file_path = (_tmp14_ = g_strconcat (_tmp12_, _tmp13_, NULL), _g_free0 (_tmp12_), _g_free0 (_tmp11_), _tmp14_);
		_tmp16_ = g_file_info_get_file_type (file_info);
		if (_tmp16_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp17_ = NULL;
			gboolean _tmp18_;
			_tmp17_ = g_file_info_get_name (file_info);
			_tmp18_ = beat_box_file_operator_is_image_file_type (self, _tmp17_);
			_tmp15_ = _tmp18_;
		} else {
			_tmp15_ = FALSE;
		}
		if (_tmp15_) {
			result = file_path;
			_g_object_unref0 (enumerator);
			_g_object_unref0 (file_info);
			_g_object_unref0 (artist_folder);
			_g_free0 (artist_folder_string);
			return result;
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally37;
	__catch37_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not find artist image: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally37:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		_g_object_unref0 (artist_folder);
		_g_free0 (artist_folder_string);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	_g_object_unref0 (file_info);
	_g_object_unref0 (artist_folder);
	_g_free0 (artist_folder_string);
	return result;
}


GdkPixbuf* beat_box_file_operator_save_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* rv = NULL;
	gboolean _tmp0_ = FALSE;
	GFile* _tmp1_ = NULL;
	GFile* file;
	GFileInputStream* filestream = NULL;
	GFileInputStream* _tmp2_ = NULL;
	GFileInputStream* _tmp3_;
	GFileInputStream* _tmp4_;
	GdkPixbuf* _tmp5_ = NULL;
	GdkPixbuf* _tmp6_;
	GdkPixbuf* _tmp7_;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	const gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	gchar* _tmp15_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	if (uri == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (uri, "") == 0;
	}
	if (_tmp0_) {
		result = NULL;
		_g_object_unref0 (rv);
		return result;
	}
	_tmp1_ = g_file_new_for_uri (uri);
	file = _tmp1_;
	_tmp2_ = g_file_read (file, NULL, &_inner_error_);
	_tmp3_ = _tmp2_;
	if (_inner_error_ != NULL) {
		goto __catch38_g_error;
	}
	_tmp4_ = _tmp3_;
	_g_object_unref0 (filestream);
	filestream = _tmp4_;
	_tmp5_ = gdk_pixbuf_new_from_stream ((GInputStream*) filestream, NULL, &_inner_error_);
	_tmp6_ = _tmp5_;
	if (_inner_error_ != NULL) {
		goto __catch38_g_error;
	}
	_tmp7_ = _tmp6_;
	_g_object_unref0 (rv);
	rv = _tmp7_;
	_tmp8_ = beat_box_song_get_file (s);
	_tmp9_ = beat_box_file_operator_get_folder (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = beat_box_file_operator_get_folder (_tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = beat_box_song_get_artist (s);
	_tmp14_ = g_strconcat (_tmp12_, _tmp13_, NULL);
	_tmp15_ = g_strconcat (_tmp14_, ".jpg", NULL);
	gdk_pixbuf_save (rv, _tmp15_, "jpeg", &_inner_error_, NULL);
	_g_free0 (_tmp15_);
	_g_free0 (_tmp14_);
	_g_free0 (_tmp12_);
	_g_free0 (_tmp10_);
	if (_inner_error_ != NULL) {
		goto __catch38_g_error;
	}
	goto __finally38;
	__catch38_g_error:
	{
		GError * err;
		GdkPixbuf* _tmp16_;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not save artist image from %s: %s\n", uri, err->message);
		_tmp16_ = NULL;
		_g_object_unref0 (rv);
		rv = _tmp16_;
		_g_error_free0 (err);
	}
	__finally38:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (filestream);
		_g_object_unref0 (file);
		_g_object_unref0 (rv);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = rv;
	_g_object_unref0 (filestream);
	_g_object_unref0 (file);
	return result;
}


static gpointer _beat_box_file_operator_save_song_thread_gthread_func (gpointer self) {
	gpointer result;
	result = beat_box_file_operator_save_song_thread (self);
	return result;
}


void beat_box_file_operator_save_songs (BeatBoxFileOperator* self, GeeCollection* to_save) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (to_save != NULL);
	{
		GeeIterator* _tmp0_ = NULL;
		GeeIterator* _s_it;
		_tmp0_ = gee_iterable_iterator ((GeeIterable*) to_save);
		_s_it = _tmp0_;
		while (TRUE) {
			gboolean _tmp1_;
			gpointer _tmp2_ = NULL;
			BeatBoxSong* s;
			gboolean _tmp3_;
			_tmp1_ = gee_iterator_next (_s_it);
			if (!_tmp1_) {
				break;
			}
			_tmp2_ = gee_iterator_get (_s_it);
			s = (BeatBoxSong*) _tmp2_;
			_tmp3_ = gee_abstract_collection_contains ((GeeAbstractCollection*) self->priv->toSave, s);
			if (!_tmp3_) {
				gee_queue_offer ((GeeQueue*) self->priv->toSave, s);
			}
			_g_object_unref0 (s);
		}
		_g_object_unref0 (_s_it);
	}
	if (!self->priv->inThread) {
		self->priv->inThread = TRUE;
		g_thread_create (_beat_box_file_operator_save_song_thread_gthread_func, self, FALSE, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch39_g_error;
		}
		goto __finally39;
		__catch39_g_error:
		{
			GError * err;
			err = _inner_error_;
			_inner_error_ = NULL;
			fprintf (stdout, "Could not create thread to rescan music folder: %s\n", err->message);
			_g_error_free0 (err);
		}
		__finally39:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


void* beat_box_file_operator_save_song_thread (BeatBoxFileOperator* self) {
	void* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	while (TRUE) {
		gpointer _tmp0_ = NULL;
		BeatBoxSong* s;
		TagLib_File* tag_file = NULL;
		const gchar* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		TagLib_File* _tmp3_ = NULL;
		TagLib_File* _tmp4_;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp6_ = FALSE;
		gboolean _tmp24_;
		_tmp0_ = gee_queue_poll ((GeeQueue*) self->priv->toSave);
		s = (BeatBoxSong*) _tmp0_;
		if (s == NULL) {
			self->priv->inThread = FALSE;
			result = NULL;
			_g_object_unref0 (s);
			return result;
		}
		_tmp1_ = beat_box_song_get_file (s);
		fprintf (stdout, "Saving file %s \n", _tmp1_);
		_tmp2_ = beat_box_song_get_file (s);
		_tmp3_ = taglib_file_new (_tmp2_);
		_tmp4_ = _tmp3_;
		_taglib_file_free0 (tag_file);
		tag_file = _tmp4_;
		if (tag_file != NULL) {
			TagLib_Tag* _tmp7_ = NULL;
			_tmp7_ = taglib_file_tag (tag_file);
			_tmp6_ = _tmp7_ != NULL;
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
			const TagLib_AudioProperties* _tmp8_ = NULL;
			_tmp8_ = taglib_file_audioproperties (tag_file);
			_tmp5_ = _tmp8_ != NULL;
		} else {
			_tmp5_ = FALSE;
		}
		if (_tmp5_) {
			TagLib_Tag* _tmp9_ = NULL;
			const gchar* _tmp10_ = NULL;
			TagLib_Tag* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			TagLib_Tag* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			TagLib_Tag* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			TagLib_Tag* _tmp17_ = NULL;
			const gchar* _tmp18_ = NULL;
			TagLib_Tag* _tmp19_ = NULL;
			gint _tmp20_;
			TagLib_Tag* _tmp21_ = NULL;
			gint _tmp22_;
			_tmp9_ = taglib_file_tag (tag_file);
			_tmp10_ = beat_box_song_get_title (s);
			taglib_tag_set_title (_tmp9_, _tmp10_);
			_tmp11_ = taglib_file_tag (tag_file);
			_tmp12_ = beat_box_song_get_artist (s);
			taglib_tag_set_artist (_tmp11_, _tmp12_);
			_tmp13_ = taglib_file_tag (tag_file);
			_tmp14_ = beat_box_song_get_album (s);
			taglib_tag_set_album (_tmp13_, _tmp14_);
			_tmp15_ = taglib_file_tag (tag_file);
			_tmp16_ = beat_box_song_get_genre (s);
			taglib_tag_set_genre (_tmp15_, _tmp16_);
			_tmp17_ = taglib_file_tag (tag_file);
			_tmp18_ = beat_box_song_get_comment (s);
			taglib_tag_set_comment (_tmp17_, _tmp18_);
			_tmp19_ = taglib_file_tag (tag_file);
			_tmp20_ = beat_box_song_get_year (s);
			taglib_tag_set_year (_tmp19_, (guint) _tmp20_);
			_tmp21_ = taglib_file_tag (tag_file);
			_tmp22_ = beat_box_song_get_track (s);
			taglib_tag_set_track (_tmp21_, (guint) _tmp22_);
			taglib_file_save (tag_file);
			__finally40:
			if (_inner_error_ != NULL) {
				_taglib_file_free0 (tag_file);
				_g_object_unref0 (s);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		} else {
			const gchar* _tmp23_ = NULL;
			_tmp23_ = beat_box_song_get_file (s);
			fprintf (stdout, "Could not save %s.\n", _tmp23_);
		}
		_tmp24_ = beat_box_settings_getUpdateFolderHierarchy (self->priv->settings);
		if (_tmp24_) {
			beat_box_file_operator_update_file_hierarchy (self, s, TRUE);
		}
		_taglib_file_free0 (tag_file);
		_g_object_unref0 (s);
	}
}


void beat_box_file_operator_update_file_hierarchy (BeatBoxFileOperator* self, BeatBoxSong* s, gboolean delete_old) {
	const gchar* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFile* original;
	GFileInfo* _tmp2_ = NULL;
	GFileInfo* file_info;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* _tmp5_;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	const gchar* _tmp16_ = NULL;
	gchar* _tmp17_;
	GFile* _tmp18_ = NULL;
	GFile* _tmp19_;
	GFile* dest;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_;
	gchar* _tmp22_ = NULL;
	gchar* _tmp23_;
	gboolean _tmp24_;
	GFile* _tmp25_ = NULL;
	GFile* _tmp26_;
	GFile* _tmp27_ = NULL;
	GFile* _tmp28_;
	gboolean _tmp29_;
	gboolean _tmp30_;
	gboolean success;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (s != NULL);
	_tmp0_ = beat_box_song_get_file (s);
	_tmp1_ = g_file_new_for_path (_tmp0_);
	original = _tmp1_;
	_tmp2_ = g_file_query_info (original, "*", G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
	file_info = _tmp2_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (original);
		goto __catch41_g_error;
	}
	_tmp3_ = beat_box_settings_getMusicFolder (self->priv->settings);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat (_tmp4_, "/", NULL);
	_tmp6_ = beat_box_song_get_artist (s);
	_tmp7_ = string_replace (_tmp6_, "/", "_");
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strconcat (_tmp5_, _tmp8_, NULL);
	_tmp10_ = g_strconcat (_tmp9_, "/", NULL);
	_tmp11_ = beat_box_song_get_album (s);
	_tmp12_ = string_replace (_tmp11_, "/", "_");
	_tmp13_ = _tmp12_;
	_tmp14_ = g_strconcat (_tmp10_, _tmp13_, NULL);
	_tmp15_ = g_strconcat (_tmp14_, "/", NULL);
	_tmp16_ = g_file_info_get_name (file_info);
	_tmp17_ = g_strconcat (_tmp15_, _tmp16_, NULL);
	_tmp18_ = g_file_new_for_path (_tmp17_);
	dest = (_tmp19_ = _tmp18_, _g_free0 (_tmp17_), _g_free0 (_tmp15_), _g_free0 (_tmp14_), _g_free0 (_tmp13_), _g_free0 (_tmp10_), _g_free0 (_tmp9_), _g_free0 (_tmp8_), _g_free0 (_tmp5_), _g_free0 (_tmp4_), _tmp19_);
	_tmp20_ = g_file_get_path (original);
	_tmp21_ = _tmp20_;
	_tmp22_ = g_file_get_path (dest);
	_tmp23_ = _tmp22_;
	if ((_tmp24_ = g_strcmp0 (_tmp21_, _tmp23_) == 0, _g_free0 (_tmp23_), _g_free0 (_tmp21_), _tmp24_)) {
		_g_object_unref0 (dest);
		_g_object_unref0 (file_info);
		_g_object_unref0 (original);
		return;
	}
	_tmp25_ = g_file_get_parent (dest);
	_tmp26_ = _tmp25_;
	_tmp27_ = g_file_get_parent (_tmp26_);
	_tmp28_ = _tmp27_;
	_tmp29_ = g_file_query_exists (_tmp28_, NULL);
	if ((_tmp30_ = !_tmp29_, _g_object_unref0 (_tmp28_), _g_object_unref0 (_tmp26_), _tmp30_)) {
		GFile* _tmp31_ = NULL;
		GFile* _tmp32_;
		GFile* _tmp33_ = NULL;
		GFile* _tmp34_;
		gchar* _tmp35_ = NULL;
		gchar* _tmp36_;
		GFile* _tmp37_ = NULL;
		GFile* _tmp38_;
		GFile* _tmp39_ = NULL;
		GFile* _tmp40_;
		GFile* _tmp41_ = NULL;
		GFile* _tmp42_;
		_tmp31_ = g_file_get_parent (dest);
		_tmp32_ = _tmp31_;
		_tmp33_ = g_file_get_parent (_tmp32_);
		_tmp34_ = _tmp33_;
		_tmp35_ = g_file_get_path (_tmp34_);
		_tmp36_ = _tmp35_;
		fprintf (stdout, "artist folder %s does not exist\n", _tmp36_);
		_g_free0 (_tmp36_);
		_g_object_unref0 (_tmp34_);
		_g_object_unref0 (_tmp32_);
		_tmp37_ = g_file_get_parent (dest);
		_tmp38_ = _tmp37_;
		_tmp39_ = g_file_get_parent (_tmp38_);
		_tmp40_ = _tmp39_;
		g_file_make_directory (_tmp40_, NULL, &_inner_error_);
		_g_object_unref0 (_tmp40_);
		_g_object_unref0 (_tmp38_);
		if (_inner_error_ != NULL) {
			goto __catch42_g_error;
		}
		_tmp41_ = g_file_get_parent (dest);
		_tmp42_ = _tmp41_;
		g_file_make_directory (_tmp42_, NULL, &_inner_error_);
		_g_object_unref0 (_tmp42_);
		if (_inner_error_ != NULL) {
			goto __catch42_g_error;
		}
		goto __finally42;
		__catch42_g_error:
		{
			GError * err;
			err = _inner_error_;
			_inner_error_ = NULL;
			fprintf (stdout, "Could not create folder to copy to: %s\n", err->message);
			_g_error_free0 (err);
		}
		__finally42:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (dest);
			_g_object_unref0 (file_info);
			_g_object_unref0 (original);
			goto __catch41_g_error;
		}
	} else {
		GFile* _tmp43_ = NULL;
		GFile* _tmp44_;
		gboolean _tmp45_;
		gboolean _tmp46_;
		_tmp43_ = g_file_get_parent (dest);
		_tmp44_ = _tmp43_;
		_tmp45_ = g_file_query_exists (_tmp44_, NULL);
		if ((_tmp46_ = !_tmp45_, _g_object_unref0 (_tmp44_), _tmp46_)) {
			GFile* _tmp47_ = NULL;
			GFile* _tmp48_;
			gchar* _tmp49_ = NULL;
			gchar* _tmp50_;
			GFile* _tmp51_ = NULL;
			GFile* _tmp52_;
			_tmp47_ = g_file_get_parent (dest);
			_tmp48_ = _tmp47_;
			_tmp49_ = g_file_get_path (_tmp48_);
			_tmp50_ = _tmp49_;
			fprintf (stdout, "album folder %s does not exist\n", _tmp50_);
			_g_free0 (_tmp50_);
			_g_object_unref0 (_tmp48_);
			_tmp51_ = g_file_get_parent (dest);
			_tmp52_ = _tmp51_;
			g_file_make_directory (_tmp52_, NULL, &_inner_error_);
			_g_object_unref0 (_tmp52_);
			if (_inner_error_ != NULL) {
				goto __catch43_g_error;
			}
			goto __finally43;
			__catch43_g_error:
			{
				GError * err;
				err = _inner_error_;
				_inner_error_ = NULL;
				fprintf (stdout, "Could not create folder to copy to: %s\n", err->message);
				_g_error_free0 (err);
			}
			__finally43:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (dest);
				_g_object_unref0 (file_info);
				_g_object_unref0 (original);
				goto __catch41_g_error;
			}
		}
	}
	success = FALSE;
	if (!delete_old) {
		const gchar* _tmp53_ = NULL;
		gchar* _tmp54_ = NULL;
		gchar* _tmp55_;
		gboolean _tmp56_;
		gboolean _tmp57_;
		_tmp53_ = beat_box_song_get_file (s);
		_tmp54_ = g_file_get_path (dest);
		_tmp55_ = _tmp54_;
		fprintf (stdout, "Copying %s to %s\n", _tmp53_, _tmp55_);
		_g_free0 (_tmp55_);
		_tmp56_ = g_file_copy (original, dest, G_FILE_COPY_NONE, NULL, NULL, NULL, &_inner_error_);
		_tmp57_ = _tmp56_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (dest);
			_g_object_unref0 (file_info);
			_g_object_unref0 (original);
			goto __catch41_g_error;
		}
		success = _tmp57_;
	} else {
		const gchar* _tmp58_ = NULL;
		gchar* _tmp59_ = NULL;
		gchar* _tmp60_;
		gboolean _tmp61_;
		gboolean _tmp62_;
		_tmp58_ = beat_box_song_get_file (s);
		_tmp59_ = g_file_get_path (dest);
		_tmp60_ = _tmp59_;
		fprintf (stdout, "Moving %s to %s\n", _tmp58_, _tmp60_);
		_g_free0 (_tmp60_);
		_tmp61_ = g_file_move (original, dest, G_FILE_COPY_NONE, NULL, NULL, NULL, &_inner_error_);
		_tmp62_ = _tmp61_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (dest);
			_g_object_unref0 (file_info);
			_g_object_unref0 (original);
			goto __catch41_g_error;
		}
		success = _tmp62_;
	}
	if (success) {
		gchar* _tmp63_ = NULL;
		gchar* _tmp64_;
		_tmp63_ = g_file_get_path (dest);
		_tmp64_ = _tmp63_;
		beat_box_song_set_file (s, _tmp64_);
		_g_free0 (_tmp64_);
	} else {
		const gchar* _tmp65_ = NULL;
		gchar* _tmp66_ = NULL;
		gchar* _tmp67_;
		_tmp65_ = beat_box_song_get_file (s);
		_tmp66_ = g_file_get_path (dest);
		_tmp67_ = _tmp66_;
		fprintf (stdout, "Failure: Could not copy imported song %s to media folder %s\n", _tmp65_, _tmp67_);
		_g_free0 (_tmp67_);
	}
	if (delete_old) {
		GFile* _tmp68_ = NULL;
		GFile* _tmp69_;
		gint _tmp70_;
		gint _tmp71_;
		gint old_folder_items;
		_tmp68_ = g_file_get_parent (original);
		_tmp69_ = _tmp68_;
		_tmp70_ = beat_box_file_operator_count_music_files (self, _tmp69_);
		old_folder_items = (_tmp71_ = _tmp70_, _g_object_unref0 (_tmp69_), _tmp71_);
		if (old_folder_items == 0) {
			GFile* _tmp72_ = NULL;
			GFile* _tmp73_;
			gchar* _tmp74_ = NULL;
			gchar* _tmp75_;
			GFile* _tmp76_ = NULL;
			GFile* _tmp77_;
			_tmp72_ = g_file_get_parent (original);
			_tmp73_ = _tmp72_;
			_tmp74_ = g_file_get_path (_tmp73_);
			_tmp75_ = _tmp74_;
			fprintf (stdout, "going to delete %s because no files are in it\n", _tmp75_);
			_g_free0 (_tmp75_);
			_g_object_unref0 (_tmp73_);
			_tmp76_ = g_file_get_parent (original);
			_tmp77_ = _tmp76_;
			g_file_delete (_tmp77_, NULL, &_inner_error_);
			_g_object_unref0 (_tmp77_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (dest);
				_g_object_unref0 (file_info);
				_g_object_unref0 (original);
				goto __catch41_g_error;
			}
		}
	}
	_g_object_unref0 (dest);
	_g_object_unref0 (file_info);
	_g_object_unref0 (original);
	goto __finally41;
	__catch41_g_error:
	{
		GError * err;
		const gchar* _tmp78_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp78_ = beat_box_song_get_file (s);
		fprintf (stdout, "Could not copy imported song %s to media folder: %s\n", _tmp78_, err->message);
		_g_error_free0 (err);
	}
	__finally41:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void beat_box_file_operator_remove_songs (BeatBoxFileOperator* self, GeeCollection* toRemove) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (toRemove != NULL);
	{
		GeeIterator* _tmp0_ = NULL;
		GeeIterator* _s_it;
		_tmp0_ = gee_iterable_iterator ((GeeIterable*) toRemove);
		_s_it = _tmp0_;
		while (TRUE) {
			gboolean _tmp1_;
			gpointer _tmp2_ = NULL;
			gchar* s;
			GFile* _tmp3_ = NULL;
			GFile* file;
			GFile* _tmp4_ = NULL;
			GFile* _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			gint old_folder_items;
			_tmp1_ = gee_iterator_next (_s_it);
			if (!_tmp1_) {
				break;
			}
			_tmp2_ = gee_iterator_get (_s_it);
			s = (gchar*) _tmp2_;
			_tmp3_ = g_file_new_for_path (s);
			file = _tmp3_;
			g_file_trash (file, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (file);
				goto __catch44_g_error;
			}
			_tmp4_ = g_file_get_parent (file);
			_tmp5_ = _tmp4_;
			_tmp6_ = beat_box_file_operator_count_music_files (self, _tmp5_);
			old_folder_items = (_tmp7_ = _tmp6_, _g_object_unref0 (_tmp5_), _tmp7_);
			if (old_folder_items == 0) {
				GFile* _tmp8_ = NULL;
				GFile* _tmp9_;
				gchar* _tmp10_ = NULL;
				gchar* _tmp11_;
				GFile* _tmp12_ = NULL;
				GFile* _tmp13_;
				GFile* _tmp14_ = NULL;
				GFile* _tmp15_;
				gint _tmp16_;
				gint _tmp17_;
				gint old_folder_parent_items;
				_tmp8_ = g_file_get_parent (file);
				_tmp9_ = _tmp8_;
				_tmp10_ = g_file_get_path (_tmp9_);
				_tmp11_ = _tmp10_;
				fprintf (stdout, "going to delete %s because no files are in it\n", _tmp11_);
				_g_free0 (_tmp11_);
				_g_object_unref0 (_tmp9_);
				_tmp12_ = g_file_get_parent (file);
				_tmp13_ = _tmp12_;
				_tmp14_ = g_file_get_parent (_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = beat_box_file_operator_count_music_files (self, _tmp15_);
				old_folder_parent_items = (_tmp17_ = _tmp16_, _g_object_unref0 (_tmp15_), _g_object_unref0 (_tmp13_), _tmp17_);
				if (old_folder_parent_items == 0) {
					GFile* _tmp18_ = NULL;
					GFile* _tmp19_;
					GFile* _tmp20_ = NULL;
					GFile* _tmp21_;
					gchar* _tmp22_ = NULL;
					gchar* _tmp23_;
					_tmp18_ = g_file_get_parent (file);
					_tmp19_ = _tmp18_;
					_tmp20_ = g_file_get_parent (_tmp19_);
					_tmp21_ = _tmp20_;
					_tmp22_ = g_file_get_path (_tmp21_);
					_tmp23_ = _tmp22_;
					fprintf (stdout, "going to delete %s because no files are in it\n", _tmp23_);
					_g_free0 (_tmp23_);
					_g_object_unref0 (_tmp21_);
					_g_object_unref0 (_tmp19_);
				}
			}
			_g_object_unref0 (file);
			goto __finally44;
			__catch44_g_error:
			{
				GError * err;
				err = _inner_error_;
				_inner_error_ = NULL;
				fprintf (stdout, "Could not move file %s to trash: %s (you could be using a file system " \
"which is not supported)\n", s, err->message);
				_g_error_free0 (err);
			}
			__finally44:
			if (_inner_error_ != NULL) {
				_g_free0 (s);
				_g_object_unref0 (_s_it);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_g_free0 (s);
		}
		_g_object_unref0 (_s_it);
	}
}


static void g_cclosure_user_marshal_VOID__STRING_DOUBLE (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_DOUBLE) (gpointer data1, const char* arg_1, gdouble arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_DOUBLE callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_DOUBLE) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_double (param_values + 2), data2);
}


static void beat_box_file_operator_class_init (BeatBoxFileOperatorClass * klass) {
	beat_box_file_operator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BeatBoxFileOperatorPrivate));
	G_OBJECT_CLASS (klass)->finalize = beat_box_file_operator_finalize;
	g_signal_new ("fo_progress", BEAT_BOX_TYPE_FILE_OPERATOR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_DOUBLE, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_DOUBLE);
}


static void beat_box_file_operator_instance_init (BeatBoxFileOperator * self) {
	self->priv = BEAT_BOX_FILE_OPERATOR_GET_PRIVATE (self);
}


static void beat_box_file_operator_finalize (GObject* obj) {
	BeatBoxFileOperator * self;
	self = BEAT_BOX_FILE_OPERATOR (obj);
	_g_object_unref0 (self->priv->lm);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->toSave);
	G_OBJECT_CLASS (beat_box_file_operator_parent_class)->finalize (obj);
}


GType beat_box_file_operator_get_type (void) {
	static volatile gsize beat_box_file_operator_type_id__volatile = 0;
	if (g_once_init_enter (&beat_box_file_operator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BeatBoxFileOperatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beat_box_file_operator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BeatBoxFileOperator), 0, (GInstanceInitFunc) beat_box_file_operator_instance_init, NULL };
		GType beat_box_file_operator_type_id;
		beat_box_file_operator_type_id = g_type_register_static (G_TYPE_OBJECT, "BeatBoxFileOperator", &g_define_type_info, 0);
		g_once_init_leave (&beat_box_file_operator_type_id__volatile, beat_box_file_operator_type_id);
	}
	return beat_box_file_operator_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



