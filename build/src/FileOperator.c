/* FileOperator.c generated by valac 0.11.7, the Vala compiler
 * generated from FileOperator.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <tag_c.h>
#include <time.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <gtk/gtk.h>


#define BEAT_BOX_TYPE_FILE_OPERATOR (beat_box_file_operator_get_type ())
#define BEAT_BOX_FILE_OPERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperator))
#define BEAT_BOX_FILE_OPERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperatorClass))
#define BEAT_BOX_IS_FILE_OPERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_FILE_OPERATOR))
#define BEAT_BOX_IS_FILE_OPERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_FILE_OPERATOR))
#define BEAT_BOX_FILE_OPERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperatorClass))

typedef struct _BeatBoxFileOperator BeatBoxFileOperator;
typedef struct _BeatBoxFileOperatorClass BeatBoxFileOperatorClass;
typedef struct _BeatBoxFileOperatorPrivate BeatBoxFileOperatorPrivate;

#define BEAT_BOX_TYPE_LIBRARY_MANAGER (beat_box_library_manager_get_type ())
#define BEAT_BOX_LIBRARY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_LIBRARY_MANAGER, BeatBoxLibraryManager))
#define BEAT_BOX_LIBRARY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_LIBRARY_MANAGER, BeatBoxLibraryManagerClass))
#define BEAT_BOX_IS_LIBRARY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_LIBRARY_MANAGER))
#define BEAT_BOX_IS_LIBRARY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_LIBRARY_MANAGER))
#define BEAT_BOX_LIBRARY_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_LIBRARY_MANAGER, BeatBoxLibraryManagerClass))

typedef struct _BeatBoxLibraryManager BeatBoxLibraryManager;
typedef struct _BeatBoxLibraryManagerClass BeatBoxLibraryManagerClass;

#define BEAT_BOX_TYPE_SETTINGS (beat_box_settings_get_type ())
#define BEAT_BOX_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettings))
#define BEAT_BOX_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettingsClass))
#define BEAT_BOX_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_SETTINGS))
#define BEAT_BOX_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_SETTINGS))
#define BEAT_BOX_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettingsClass))

typedef struct _BeatBoxSettings BeatBoxSettings;
typedef struct _BeatBoxSettingsClass BeatBoxSettingsClass;

#define BEAT_BOX_TYPE_SONG (beat_box_song_get_type ())
#define BEAT_BOX_SONG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_SONG, BeatBoxSong))
#define BEAT_BOX_SONG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_SONG, BeatBoxSongClass))
#define BEAT_BOX_IS_SONG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_SONG))
#define BEAT_BOX_IS_SONG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_SONG))
#define BEAT_BOX_SONG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_SONG, BeatBoxSongClass))

typedef struct _BeatBoxSong BeatBoxSong;
typedef struct _BeatBoxSongClass BeatBoxSongClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _taglib_file_free0(var) ((var == NULL) ? NULL : (var = (taglib_file_free (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
typedef struct _BeatBoxLibraryManagerPrivate BeatBoxLibraryManagerPrivate;

#define BEAT_BOX_TYPE_LIBRARY_WINDOW (beat_box_library_window_get_type ())
#define BEAT_BOX_LIBRARY_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_LIBRARY_WINDOW, BeatBoxLibraryWindow))
#define BEAT_BOX_LIBRARY_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_LIBRARY_WINDOW, BeatBoxLibraryWindowClass))
#define BEAT_BOX_IS_LIBRARY_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_LIBRARY_WINDOW))
#define BEAT_BOX_IS_LIBRARY_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_LIBRARY_WINDOW))
#define BEAT_BOX_LIBRARY_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_LIBRARY_WINDOW, BeatBoxLibraryWindowClass))

typedef struct _BeatBoxLibraryWindow BeatBoxLibraryWindow;
typedef struct _BeatBoxLibraryWindowClass BeatBoxLibraryWindowClass;

#define BEAT_BOX_TYPE_DATA_BASE_MANAGER (beat_box_data_base_manager_get_type ())
#define BEAT_BOX_DATA_BASE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_DATA_BASE_MANAGER, BeatBoxDataBaseManager))
#define BEAT_BOX_DATA_BASE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_DATA_BASE_MANAGER, BeatBoxDataBaseManagerClass))
#define BEAT_BOX_IS_DATA_BASE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_DATA_BASE_MANAGER))
#define BEAT_BOX_IS_DATA_BASE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_DATA_BASE_MANAGER))
#define BEAT_BOX_DATA_BASE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_DATA_BASE_MANAGER, BeatBoxDataBaseManagerClass))

typedef struct _BeatBoxDataBaseManager BeatBoxDataBaseManager;
typedef struct _BeatBoxDataBaseManagerClass BeatBoxDataBaseManagerClass;

#define BEAT_BOX_TYPE_DATA_BASE_UPDATER (beat_box_data_base_updater_get_type ())
#define BEAT_BOX_DATA_BASE_UPDATER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_DATA_BASE_UPDATER, BeatBoxDataBaseUpdater))
#define BEAT_BOX_DATA_BASE_UPDATER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_DATA_BASE_UPDATER, BeatBoxDataBaseUpdaterClass))
#define BEAT_BOX_IS_DATA_BASE_UPDATER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_DATA_BASE_UPDATER))
#define BEAT_BOX_IS_DATA_BASE_UPDATER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_DATA_BASE_UPDATER))
#define BEAT_BOX_DATA_BASE_UPDATER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_DATA_BASE_UPDATER, BeatBoxDataBaseUpdaterClass))

typedef struct _BeatBoxDataBaseUpdater BeatBoxDataBaseUpdater;
typedef struct _BeatBoxDataBaseUpdaterClass BeatBoxDataBaseUpdaterClass;

#define BEAT_BOX_TYPE_STREAM_PLAYER (beat_box_stream_player_get_type ())
#define BEAT_BOX_STREAM_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_STREAM_PLAYER, BeatBoxStreamPlayer))
#define BEAT_BOX_STREAM_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_STREAM_PLAYER, BeatBoxStreamPlayerClass))
#define BEAT_BOX_IS_STREAM_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_STREAM_PLAYER))
#define BEAT_BOX_IS_STREAM_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_STREAM_PLAYER))
#define BEAT_BOX_STREAM_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_STREAM_PLAYER, BeatBoxStreamPlayerClass))

typedef struct _BeatBoxStreamPlayer BeatBoxStreamPlayer;
typedef struct _BeatBoxStreamPlayerClass BeatBoxStreamPlayerClass;

#define LAST_FM_TYPE_CORE (last_fm_core_get_type ())
#define LAST_FM_CORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LAST_FM_TYPE_CORE, LastFMCore))
#define LAST_FM_CORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), LAST_FM_TYPE_CORE, LastFMCoreClass))
#define LAST_FM_IS_CORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LAST_FM_TYPE_CORE))
#define LAST_FM_IS_CORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), LAST_FM_TYPE_CORE))
#define LAST_FM_CORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), LAST_FM_TYPE_CORE, LastFMCoreClass))

typedef struct _LastFMCore LastFMCore;
typedef struct _LastFMCoreClass LastFMCoreClass;

#define BEAT_BOX_TYPE_TREE_VIEW_SETUP (beat_box_tree_view_setup_get_type ())
#define BEAT_BOX_TREE_VIEW_SETUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_TREE_VIEW_SETUP, BeatBoxTreeViewSetup))
#define BEAT_BOX_TREE_VIEW_SETUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_TREE_VIEW_SETUP, BeatBoxTreeViewSetupClass))
#define BEAT_BOX_IS_TREE_VIEW_SETUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_TREE_VIEW_SETUP))
#define BEAT_BOX_IS_TREE_VIEW_SETUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_TREE_VIEW_SETUP))
#define BEAT_BOX_TREE_VIEW_SETUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_TREE_VIEW_SETUP, BeatBoxTreeViewSetupClass))

typedef struct _BeatBoxTreeViewSetup BeatBoxTreeViewSetup;
typedef struct _BeatBoxTreeViewSetupClass BeatBoxTreeViewSetupClass;

#define BEAT_BOX_TYPE_SONG_INFO (beat_box_song_info_get_type ())
#define BEAT_BOX_SONG_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_SONG_INFO, BeatBoxSongInfo))
#define BEAT_BOX_SONG_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_SONG_INFO, BeatBoxSongInfoClass))
#define BEAT_BOX_IS_SONG_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_SONG_INFO))
#define BEAT_BOX_IS_SONG_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_SONG_INFO))
#define BEAT_BOX_SONG_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_SONG_INFO, BeatBoxSongInfoClass))

typedef struct _BeatBoxSongInfo BeatBoxSongInfo;
typedef struct _BeatBoxSongInfoClass BeatBoxSongInfoClass;

#define BEAT_BOX_LIBRARY_MANAGER_TYPE_REPEAT (beat_box_library_manager_repeat_get_type ())

#define BEAT_BOX_LIBRARY_MANAGER_TYPE_SHUFFLE (beat_box_library_manager_shuffle_get_type ())

struct _BeatBoxFileOperator {
	GObject parent_instance;
	BeatBoxFileOperatorPrivate * priv;
};

struct _BeatBoxFileOperatorClass {
	GObjectClass parent_class;
};

struct _BeatBoxFileOperatorPrivate {
	BeatBoxLibraryManager* lm;
	BeatBoxSettings* settings;
	gboolean inThread;
	GeeLinkedList* toSave;
	gint index;
	gint item_count;
};

typedef enum  {
	BEAT_BOX_LIBRARY_MANAGER_REPEAT_OFF,
	BEAT_BOX_LIBRARY_MANAGER_REPEAT_SONG,
	BEAT_BOX_LIBRARY_MANAGER_REPEAT_ALBUM,
	BEAT_BOX_LIBRARY_MANAGER_REPEAT_ARTIST,
	BEAT_BOX_LIBRARY_MANAGER_REPEAT_ALL
} BeatBoxLibraryManagerRepeat;

typedef enum  {
	BEAT_BOX_LIBRARY_MANAGER_SHUFFLE_OFF,
	BEAT_BOX_LIBRARY_MANAGER_SHUFFLE_ALL
} BeatBoxLibraryManagerShuffle;

struct _BeatBoxLibraryManager {
	GObject parent_instance;
	BeatBoxLibraryManagerPrivate * priv;
	BeatBoxLibraryWindow* lw;
	BeatBoxSettings* settings;
	BeatBoxDataBaseManager* dbm;
	BeatBoxDataBaseUpdater* dbu;
	BeatBoxFileOperator* fo;
	BeatBoxStreamPlayer* player;
	LastFMCore* lfm;
	BeatBoxTreeViewSetup* music_setup;
	BeatBoxTreeViewSetup* similar_setup;
	BeatBoxTreeViewSetup* queue_setup;
	BeatBoxTreeViewSetup* history_setup;
	gint _played_index;
	gint _current_index;
	gint _current_shuffled_index;
	BeatBoxSongInfo* song_info;
	gboolean playing;
	BeatBoxLibraryManagerRepeat repeat;
	BeatBoxLibraryManagerShuffle shuffle;
	gboolean doing_file_operations;
};

struct _BeatBoxLibraryManagerClass {
	GObjectClass parent_class;
	void (*dbProgress) (BeatBoxLibraryManager* self, const gchar* message, gdouble progress);
};


static gpointer beat_box_file_operator_parent_class = NULL;

GType beat_box_file_operator_get_type (void) G_GNUC_CONST;
GType beat_box_library_manager_get_type (void) G_GNUC_CONST;
GType beat_box_settings_get_type (void) G_GNUC_CONST;
GType beat_box_song_get_type (void) G_GNUC_CONST;
#define BEAT_BOX_FILE_OPERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperatorPrivate))
enum  {
	BEAT_BOX_FILE_OPERATOR_DUMMY_PROPERTY
};
BeatBoxFileOperator* beat_box_file_operator_new (BeatBoxLibraryManager* lmm, BeatBoxSettings* sett);
BeatBoxFileOperator* beat_box_file_operator_construct (GType object_type, BeatBoxLibraryManager* lmm, BeatBoxSettings* sett);
void beat_box_file_operator_resetProgress (BeatBoxFileOperator* self, gint items);
static gboolean beat_box_file_operator_is_valid_file_type (BeatBoxFileOperator* self, const gchar* type);
gint beat_box_file_operator_count_music_files (BeatBoxFileOperator* self, GFile* music_folder);
void beat_box_file_operator_get_music_files (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** songs, GeeLinkedList** not_imported);
BeatBoxSong* beat_box_file_operator_import_song (BeatBoxFileOperator* self, const gchar* file_path);
void beat_box_file_operator_get_music_files_individually (BeatBoxFileOperator* self, GeeLinkedList* files, GeeLinkedList** songs, GeeLinkedList** not_imported);
void beat_box_file_operator_rescan_music (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** current_song_paths, GeeLinkedList** not_imported, GeeLinkedList** new_songs);
BeatBoxSong* beat_box_song_new (const gchar* file);
BeatBoxSong* beat_box_song_construct (GType object_type, const gchar* file);
void beat_box_song_set_title (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_artist (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_album (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_genre (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_comment (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_year (BeatBoxSong* self, gint value);
void beat_box_song_set_track (BeatBoxSong* self, gint value);
void beat_box_song_set_bitrate (BeatBoxSong* self, gint value);
void beat_box_song_set_length (BeatBoxSong* self, gint value);
void beat_box_song_set_samplerate (BeatBoxSong* self, gint value);
void beat_box_song_set_date_added (BeatBoxSong* self, gint value);
const gchar* beat_box_song_get_title (BeatBoxSong* self);
const gchar* beat_box_song_get_artist (BeatBoxSong* self);
static gboolean beat_box_file_operator_is_image_file_type (BeatBoxFileOperator* self, const gchar* type);
gchar* beat_box_file_operator_get_folder (const gchar* file);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
gchar* beat_box_file_operator_find_album (BeatBoxFileOperator* self, BeatBoxSong* s);
const gchar* beat_box_song_get_file (BeatBoxSong* self);
const gchar* beat_box_song_get_album (BeatBoxSong* self);
GdkPixbuf* beat_box_file_operator_save_album (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri);
gchar* beat_box_file_operator_find_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s);
GdkPixbuf* beat_box_file_operator_save_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri);
void beat_box_file_operator_save_songs (BeatBoxFileOperator* self, GeeCollection* to_save);
void* beat_box_file_operator_save_song_thread (BeatBoxFileOperator* self);
static gpointer _beat_box_file_operator_save_song_thread_gthread_func (gpointer self);
const gchar* beat_box_song_get_genre (BeatBoxSong* self);
const gchar* beat_box_song_get_comment (BeatBoxSong* self);
gint beat_box_song_get_year (BeatBoxSong* self);
gint beat_box_song_get_track (BeatBoxSong* self);
gboolean beat_box_settings_getUpdateFolderHierarchy (BeatBoxSettings* self);
void beat_box_file_operator_update_file_hierarchy (BeatBoxFileOperator* self, BeatBoxSong* s, gboolean delete_old);
gchar* beat_box_settings_getMusicFolder (BeatBoxSettings* self);
void beat_box_song_set_file (BeatBoxSong* self, const gchar* value);
void beat_box_file_operator_remove_songs (BeatBoxFileOperator* self, GeeCollection* toRemove);
GType beat_box_library_window_get_type (void) G_GNUC_CONST;
GType beat_box_data_base_manager_get_type (void) G_GNUC_CONST;
GType beat_box_data_base_updater_get_type (void) G_GNUC_CONST;
GType beat_box_stream_player_get_type (void) G_GNUC_CONST;
GType last_fm_core_get_type (void) G_GNUC_CONST;
GType beat_box_tree_view_setup_get_type (void) G_GNUC_CONST;
GType beat_box_song_info_get_type (void) G_GNUC_CONST;
GType beat_box_library_manager_repeat_get_type (void) G_GNUC_CONST;
GType beat_box_library_manager_shuffle_get_type (void) G_GNUC_CONST;
static void g_cclosure_user_marshal_VOID__STRING_DOUBLE (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void beat_box_file_operator_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


BeatBoxFileOperator* beat_box_file_operator_construct (GType object_type, BeatBoxLibraryManager* lmm, BeatBoxSettings* sett) {
	BeatBoxFileOperator * self = NULL;
	BeatBoxLibraryManager* _tmp0_;
	BeatBoxSettings* _tmp1_;
	GeeLinkedList* _tmp2_ = NULL;
	g_return_val_if_fail (lmm != NULL, NULL);
	g_return_val_if_fail (sett != NULL, NULL);
	self = (BeatBoxFileOperator*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (lmm);
	_g_object_unref0 (self->priv->lm);
	self->priv->lm = _tmp0_;
	_tmp1_ = _g_object_ref0 (sett);
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp1_;
	self->priv->inThread = FALSE;
	_tmp2_ = gee_linked_list_new (BEAT_BOX_TYPE_SONG, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->priv->toSave);
	self->priv->toSave = _tmp2_;
	return self;
}


BeatBoxFileOperator* beat_box_file_operator_new (BeatBoxLibraryManager* lmm, BeatBoxSettings* sett) {
	return beat_box_file_operator_construct (BEAT_BOX_TYPE_FILE_OPERATOR, lmm, sett);
}


void beat_box_file_operator_resetProgress (BeatBoxFileOperator* self, gint items) {
	g_return_if_fail (self != NULL);
	self->priv->index = 0;
	self->priv->item_count = items;
}


static gboolean beat_box_file_operator_is_valid_file_type (BeatBoxFileOperator* self, const gchar* type) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gboolean _tmp8_;
	gboolean _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (type != NULL, FALSE);
	_tmp6_ = g_utf8_strdown (type, (gssize) (-1));
	_tmp7_ = _tmp6_;
	_tmp8_ = g_str_has_suffix (_tmp7_, ".mp3");
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	if (_tmp9_) {
		_tmp5_ = TRUE;
	} else {
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		gboolean _tmp12_;
		_tmp10_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp11_ = _tmp10_;
		_tmp12_ = g_str_has_suffix (_tmp11_, ".m4a");
		_tmp5_ = _tmp12_;
		_g_free0 (_tmp11_);
	}
	if (_tmp5_) {
		_tmp4_ = TRUE;
	} else {
		gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		gboolean _tmp15_;
		_tmp13_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp14_ = _tmp13_;
		_tmp15_ = g_str_has_suffix (_tmp14_, ".wma");
		_tmp4_ = _tmp15_;
		_g_free0 (_tmp14_);
	}
	if (_tmp4_) {
		_tmp3_ = TRUE;
	} else {
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		gboolean _tmp18_;
		_tmp16_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp17_ = _tmp16_;
		_tmp18_ = g_str_has_suffix (_tmp17_, ".ogg");
		_tmp3_ = _tmp18_;
		_g_free0 (_tmp17_);
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_;
		gboolean _tmp21_;
		_tmp19_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp20_ = _tmp19_;
		_tmp21_ = g_str_has_suffix (_tmp20_, ".flac");
		_tmp2_ = _tmp21_;
		_g_free0 (_tmp20_);
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gchar* _tmp22_ = NULL;
		gchar* _tmp23_;
		gboolean _tmp24_;
		_tmp22_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp23_ = _tmp22_;
		_tmp24_ = g_str_has_suffix (_tmp23_, ".mp4");
		_tmp1_ = _tmp24_;
		_g_free0 (_tmp23_);
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gchar* _tmp25_ = NULL;
		gchar* _tmp26_;
		gboolean _tmp27_;
		_tmp25_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp26_ = _tmp25_;
		_tmp27_ = g_str_has_suffix (_tmp26_, ".ogg");
		_tmp0_ = _tmp27_;
		_g_free0 (_tmp26_);
	}
	result = _tmp0_;
	return result;
}


gint beat_box_file_operator_count_music_files (BeatBoxFileOperator* self, GFile* music_folder) {
	gint result = 0;
	GFileInfo* file_info;
	GFileEnumerator* _tmp0_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (music_folder != NULL, 0);
	file_info = NULL;
	_tmp0_ = g_file_enumerate_children (music_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch30_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp1_ = NULL;
		GFileInfo* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* file_path;
		gboolean _tmp10_ = FALSE;
		GFileType _tmp11_;
		_tmp1_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch30_g_error;
		}
		_g_object_unref0 (file_info);
		file_info = _tmp2_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp3_ = g_file_get_path (music_folder);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_strconcat (_tmp4_, "/", NULL);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_file_info_get_name (file_info);
		_tmp8_ = g_strconcat (_tmp6_, _tmp7_, NULL);
		_tmp9_ = _tmp8_;
		_g_free0 (_tmp6_);
		_g_free0 (_tmp4_);
		file_path = _tmp9_;
		_tmp11_ = g_file_info_get_file_type (file_info);
		if (_tmp11_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp12_ = NULL;
			gboolean _tmp13_;
			_tmp12_ = g_file_info_get_name (file_info);
			_tmp13_ = beat_box_file_operator_is_valid_file_type (self, _tmp12_);
			_tmp10_ = _tmp13_;
		} else {
			_tmp10_ = FALSE;
		}
		if (_tmp10_) {
			self->priv->index++;
		} else {
			GFileType _tmp14_;
			_tmp14_ = g_file_info_get_file_type (file_info);
			if (_tmp14_ == G_FILE_TYPE_DIRECTORY) {
				GFile* _tmp15_ = NULL;
				GFile* _tmp16_;
				_tmp15_ = g_file_new_for_path (file_path);
				_tmp16_ = _tmp15_;
				beat_box_file_operator_count_music_files (self, _tmp16_);
				_g_object_unref0 (_tmp16_);
			}
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally30;
	__catch30_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not pre-scan music folder. Progress percentage may be off: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally30:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = self->priv->index;
	_g_object_unref0 (file_info);
	return result;
}


void beat_box_file_operator_get_music_files (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** songs, GeeLinkedList** not_imported) {
	GFileInfo* file_info;
	GFileEnumerator* _tmp0_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (music_folder != NULL);
	g_return_if_fail (songs != NULL);
	g_return_if_fail (not_imported != NULL);
	file_info = NULL;
	_tmp0_ = g_file_enumerate_children (music_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch31_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp1_ = NULL;
		GFileInfo* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* file_path;
		gboolean _tmp10_ = FALSE;
		GFileType _tmp11_;
		_tmp1_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch31_g_error;
		}
		_g_object_unref0 (file_info);
		file_info = _tmp2_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp3_ = g_file_get_path (music_folder);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_strconcat (_tmp4_, "/", NULL);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_file_info_get_name (file_info);
		_tmp8_ = g_strconcat (_tmp6_, _tmp7_, NULL);
		_tmp9_ = _tmp8_;
		_g_free0 (_tmp6_);
		_g_free0 (_tmp4_);
		file_path = _tmp9_;
		_tmp11_ = g_file_info_get_file_type (file_info);
		if (_tmp11_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp12_ = NULL;
			gboolean _tmp13_;
			_tmp12_ = g_file_info_get_name (file_info);
			_tmp13_ = beat_box_file_operator_is_valid_file_type (self, _tmp12_);
			_tmp10_ = _tmp13_;
		} else {
			_tmp10_ = FALSE;
		}
		if (_tmp10_) {
			BeatBoxSong* _tmp14_ = NULL;
			BeatBoxSong* s;
			self->priv->index = self->priv->index + 1;
			g_signal_emit_by_name (self, "fo-progress", NULL, ((gdouble) ((gdouble) self->priv->index)) / ((gdouble) self->priv->item_count));
			_tmp14_ = beat_box_file_operator_import_song (self, file_path);
			s = _tmp14_;
			if (s != NULL) {
				gee_abstract_collection_add ((GeeAbstractCollection*) (*songs), s);
			} else {
				gee_abstract_collection_add ((GeeAbstractCollection*) (*not_imported), file_path);
			}
			_g_object_unref0 (s);
		} else {
			GFileType _tmp15_;
			_tmp15_ = g_file_info_get_file_type (file_info);
			if (_tmp15_ == G_FILE_TYPE_DIRECTORY) {
				GFile* _tmp16_ = NULL;
				GFile* _tmp17_;
				_tmp16_ = g_file_new_for_path (file_path);
				_tmp17_ = _tmp16_;
				beat_box_file_operator_get_music_files (self, _tmp17_, songs, not_imported);
				_g_object_unref0 (_tmp17_);
			}
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally31;
	__catch31_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not get music: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally31:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (file_info);
}


void beat_box_file_operator_get_music_files_individually (BeatBoxFileOperator* self, GeeLinkedList* files, GeeLinkedList** songs, GeeLinkedList** not_imported) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (files != NULL);
	g_return_if_fail (songs != NULL);
	g_return_if_fail (not_imported != NULL);
	{
		GeeLinkedList* _tmp0_;
		GeeLinkedList* _file_list;
		gint _tmp1_;
		gint _file_size;
		gint _file_index;
		_tmp0_ = _g_object_ref0 (files);
		_file_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _file_list);
		_file_size = _tmp1_;
		_file_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			gchar* file;
			GFile* _tmp3_ = NULL;
			GFile* gio_file;
			GFileInfo* _tmp4_ = NULL;
			GFileInfo* file_info;
			gchar* _tmp5_ = NULL;
			gchar* file_path;
			gboolean _tmp6_ = FALSE;
			GFileType _tmp7_;
			_file_index = _file_index + 1;
			if (!(_file_index < _file_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _file_list, _file_index);
			file = (gchar*) _tmp2_;
			_tmp3_ = g_file_new_for_uri (file);
			gio_file = _tmp3_;
			_tmp4_ = g_file_query_info (gio_file, "*", G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
			file_info = _tmp4_;
			if (_inner_error_ != NULL) {
				_g_object_unref0 (gio_file);
				goto __catch32_g_error;
			}
			_tmp5_ = g_file_get_path (gio_file);
			file_path = _tmp5_;
			_tmp7_ = g_file_info_get_file_type (file_info);
			if (_tmp7_ == G_FILE_TYPE_REGULAR) {
				const gchar* _tmp8_ = NULL;
				gboolean _tmp9_;
				_tmp8_ = g_file_info_get_name (file_info);
				_tmp9_ = beat_box_file_operator_is_valid_file_type (self, _tmp8_);
				_tmp6_ = _tmp9_;
			} else {
				_tmp6_ = FALSE;
			}
			if (_tmp6_) {
				BeatBoxSong* _tmp10_ = NULL;
				BeatBoxSong* s;
				self->priv->index = self->priv->index + 1;
				g_signal_emit_by_name (self, "fo-progress", NULL, ((gdouble) ((gdouble) self->priv->index)) / ((gdouble) self->priv->item_count));
				_tmp10_ = beat_box_file_operator_import_song (self, file_path);
				s = _tmp10_;
				if (s != NULL) {
					gee_abstract_collection_add ((GeeAbstractCollection*) (*songs), s);
				} else {
					gee_abstract_collection_add ((GeeAbstractCollection*) (*not_imported), file_path);
				}
				_g_object_unref0 (s);
			} else {
				GFileType _tmp11_;
				_tmp11_ = g_file_info_get_file_type (file_info);
				if (_tmp11_ == G_FILE_TYPE_DIRECTORY) {
					GFile* _tmp12_ = NULL;
					GFile* _tmp13_;
					_tmp12_ = g_file_new_for_path (file_path);
					_tmp13_ = _tmp12_;
					beat_box_file_operator_get_music_files (self, _tmp13_, songs, not_imported);
					_g_object_unref0 (_tmp13_);
				}
			}
			_g_free0 (file_path);
			_g_object_unref0 (file_info);
			_g_object_unref0 (gio_file);
			goto __finally32;
			__catch32_g_error:
			{
				GError * err;
				err = _inner_error_;
				_inner_error_ = NULL;
				fprintf (stdout, "Could not get song %s: %s\n", file, err->message);
				_g_error_free0 (err);
			}
			__finally32:
			if (_inner_error_ != NULL) {
				_g_free0 (file);
				_g_object_unref0 (_file_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_g_free0 (file);
		}
		_g_object_unref0 (_file_list);
	}
}


/** rescans the music folder to update the db to the folder situation.
 * If song is in folder, and in db, re-add
 * If song is not in folder and in db,remove
 * If song is in both, do nothing.
 * @param music_folder The folder to rescan
 * @param current_song_paths Paths of files already in db. once file
 * is re-added, set string to "ADDED". at end, remove all songs that
 * are not re-added.
 * @return file paths of songs no longer available. TODO: should out that
 */
void beat_box_file_operator_rescan_music (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** current_song_paths, GeeLinkedList** not_imported, GeeLinkedList** new_songs) {
	GFileInfo* file_info;
	gint songs_added;
	GFileEnumerator* _tmp0_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (music_folder != NULL);
	g_return_if_fail (current_song_paths != NULL);
	g_return_if_fail (not_imported != NULL);
	g_return_if_fail (new_songs != NULL);
	file_info = NULL;
	songs_added = 0;
	_tmp0_ = g_file_enumerate_children (music_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch33_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp1_ = NULL;
		GFileInfo* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* file_path;
		gboolean _tmp10_ = FALSE;
		GFileType _tmp11_;
		_tmp1_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch33_g_error;
		}
		_g_object_unref0 (file_info);
		file_info = _tmp2_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp3_ = g_file_get_path (music_folder);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_strconcat (_tmp4_, "/", NULL);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_file_info_get_name (file_info);
		_tmp8_ = g_strconcat (_tmp6_, _tmp7_, NULL);
		_tmp9_ = _tmp8_;
		_g_free0 (_tmp6_);
		_g_free0 (_tmp4_);
		file_path = _tmp9_;
		g_signal_emit_by_name (self, "fo-progress", NULL, ((gdouble) ((gdouble) self->priv->index)) / ((gdouble) self->priv->item_count));
		_tmp11_ = g_file_info_get_file_type (file_info);
		if (_tmp11_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp12_ = NULL;
			gboolean _tmp13_;
			_tmp12_ = g_file_info_get_name (file_info);
			_tmp13_ = beat_box_file_operator_is_valid_file_type (self, _tmp12_);
			_tmp10_ = _tmp13_;
		} else {
			_tmp10_ = FALSE;
		}
		if (_tmp10_) {
			gboolean _tmp14_;
			_tmp14_ = gee_abstract_collection_contains ((GeeAbstractCollection*) (*current_song_paths), file_path);
			if (_tmp14_) {
				gee_abstract_collection_remove ((GeeAbstractCollection*) (*current_song_paths), file_path);
				self->priv->index = self->priv->index + 1;
			} else {
				gboolean _tmp15_;
				_tmp15_ = gee_abstract_collection_contains ((GeeAbstractCollection*) (*current_song_paths), file_path);
				if (!_tmp15_) {
					BeatBoxSong* _tmp16_ = NULL;
					BeatBoxSong* s;
					_tmp16_ = beat_box_file_operator_import_song (self, file_path);
					s = _tmp16_;
					if (s != NULL) {
						gee_abstract_collection_add ((GeeAbstractCollection*) (*new_songs), s);
					} else {
						gee_abstract_collection_add ((GeeAbstractCollection*) (*not_imported), file_path);
					}
					songs_added = songs_added + 1;
					_g_object_unref0 (s);
				}
			}
		} else {
			GFileType _tmp17_;
			_tmp17_ = g_file_info_get_file_type (file_info);
			if (_tmp17_ == G_FILE_TYPE_DIRECTORY) {
				GFile* _tmp18_ = NULL;
				GFile* _tmp19_;
				_tmp18_ = g_file_new_for_path (file_path);
				_tmp19_ = _tmp18_;
				beat_box_file_operator_rescan_music (self, _tmp19_, current_song_paths, not_imported, new_songs);
				_g_object_unref0 (_tmp19_);
			}
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally33;
	__catch33_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not rescan music folder: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally33:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (file_info);
}


BeatBoxSong* beat_box_file_operator_import_song (BeatBoxFileOperator* self, const gchar* file_path) {
	BeatBoxSong* result = NULL;
	BeatBoxSong* _tmp0_ = NULL;
	BeatBoxSong* s;
	TagLib_File* tag_file = NULL;
	TagLib_File* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (file_path != NULL, NULL);
	_tmp0_ = beat_box_song_new (file_path);
	s = _tmp0_;
	_tmp1_ = taglib_file_new (file_path);
	_taglib_file_free0 (tag_file);
	tag_file = _tmp1_;
	if (tag_file != NULL) {
		TagLib_Tag* _tmp4_ = NULL;
		_tmp4_ = taglib_file_tag (tag_file);
		_tmp3_ = _tmp4_ != NULL;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		const TagLib_AudioProperties* _tmp5_ = NULL;
		_tmp5_ = taglib_file_audioproperties (tag_file);
		_tmp2_ = _tmp5_ != NULL;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		TagLib_Tag* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		TagLib_Tag* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		TagLib_Tag* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		TagLib_Tag* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		TagLib_Tag* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		TagLib_Tag* _tmp16_ = NULL;
		guint _tmp17_;
		TagLib_Tag* _tmp18_ = NULL;
		guint _tmp19_;
		const TagLib_AudioProperties* _tmp20_ = NULL;
		gint _tmp21_;
		const TagLib_AudioProperties* _tmp22_ = NULL;
		gint _tmp23_;
		const TagLib_AudioProperties* _tmp24_ = NULL;
		gint _tmp25_;
		time_t _tmp26_;
		gboolean _tmp27_ = FALSE;
		const gchar* _tmp28_ = NULL;
		gboolean _tmp32_ = FALSE;
		const gchar* _tmp33_ = NULL;
		_tmp6_ = taglib_file_tag (tag_file);
		_tmp7_ = taglib_tag_title (_tmp6_);
		beat_box_song_set_title (s, _tmp7_);
		_tmp8_ = taglib_file_tag (tag_file);
		_tmp9_ = taglib_tag_artist (_tmp8_);
		beat_box_song_set_artist (s, _tmp9_);
		_tmp10_ = taglib_file_tag (tag_file);
		_tmp11_ = taglib_tag_album (_tmp10_);
		beat_box_song_set_album (s, _tmp11_);
		_tmp12_ = taglib_file_tag (tag_file);
		_tmp13_ = taglib_tag_genre (_tmp12_);
		beat_box_song_set_genre (s, _tmp13_);
		_tmp14_ = taglib_file_tag (tag_file);
		_tmp15_ = taglib_tag_comment (_tmp14_);
		beat_box_song_set_comment (s, _tmp15_);
		_tmp16_ = taglib_file_tag (tag_file);
		_tmp17_ = taglib_tag_year (_tmp16_);
		beat_box_song_set_year (s, (gint) _tmp17_);
		_tmp18_ = taglib_file_tag (tag_file);
		_tmp19_ = taglib_tag_track (_tmp18_);
		beat_box_song_set_track (s, (gint) _tmp19_);
		_tmp20_ = taglib_file_audioproperties (tag_file);
		_tmp21_ = taglib_audioproperties_bitrate (_tmp20_);
		beat_box_song_set_bitrate (s, _tmp21_);
		_tmp22_ = taglib_file_audioproperties (tag_file);
		_tmp23_ = taglib_audioproperties_length (_tmp22_);
		beat_box_song_set_length (s, _tmp23_);
		_tmp24_ = taglib_file_audioproperties (tag_file);
		_tmp25_ = taglib_audioproperties_samplerate (_tmp24_);
		beat_box_song_set_samplerate (s, _tmp25_);
		_tmp26_ = time (NULL);
		beat_box_song_set_date_added (s, (gint) _tmp26_);
		__finally34:
		_tmp28_ = beat_box_song_get_title (s);
		if (_tmp28_ == NULL) {
			_tmp27_ = TRUE;
		} else {
			const gchar* _tmp29_ = NULL;
			_tmp29_ = beat_box_song_get_title (s);
			_tmp27_ = g_strcmp0 (_tmp29_, "") == 0;
		}
		if (_tmp27_) {
			gchar** _tmp30_;
			gchar** _tmp31_ = NULL;
			gchar** paths;
			gint paths_length1;
			gint _paths_size_;
			_tmp31_ = _tmp30_ = g_strsplit (file_path, "/", 0);
			paths = _tmp31_;
			paths_length1 = _vala_array_length (_tmp30_);
			_paths_size_ = _vala_array_length (_tmp30_);
			beat_box_song_set_title (s, paths[paths_length1 - 1]);
			paths = (_vala_array_free (paths, paths_length1, (GDestroyNotify) g_free), NULL);
		}
		_tmp33_ = beat_box_song_get_artist (s);
		if (_tmp33_ == NULL) {
			_tmp32_ = TRUE;
		} else {
			const gchar* _tmp34_ = NULL;
			_tmp34_ = beat_box_song_get_artist (s);
			_tmp32_ = g_strcmp0 (_tmp34_, "") == 0;
		}
		if (_tmp32_) {
			beat_box_song_set_artist (s, "Unknown");
		}
		if (_inner_error_ != NULL) {
			_taglib_file_free0 (tag_file);
			_g_object_unref0 (s);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	} else {
		result = NULL;
		_taglib_file_free0 (tag_file);
		_g_object_unref0 (s);
		return result;
	}
	result = s;
	_taglib_file_free0 (tag_file);
	return result;
}


static gboolean beat_box_file_operator_is_image_file_type (BeatBoxFileOperator* self, const gchar* type) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (type != NULL, FALSE);
	_tmp1_ = g_str_has_suffix (type, ".jpg");
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp2_;
		_tmp2_ = g_str_has_suffix (type, ".png");
		_tmp0_ = _tmp2_;
	}
	result = _tmp0_;
	return result;
}


static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


gchar* beat_box_file_operator_get_folder (const gchar* file) {
	gchar* result = NULL;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** paths;
	gint paths_length1;
	gint _paths_size_;
	gboolean _tmp2_;
	gchar* _tmp4_;
	gchar* folder_string;
	g_return_val_if_fail (file != NULL, NULL);
	_tmp1_ = _tmp0_ = g_strsplit (file, "/", 0);
	paths = _tmp1_;
	paths_length1 = _vala_array_length (_tmp0_);
	_paths_size_ = _vala_array_length (_tmp0_);
	_tmp2_ = g_str_has_suffix (file, "/");
	if (!_tmp2_) {
		gchar* _tmp3_;
		_tmp3_ = g_strdup (" ");
		_vala_array_add1 (&paths, &paths_length1, &_paths_size_, _tmp3_);
	}
	_tmp4_ = g_strdup ("");
	folder_string = _tmp4_;
	{
		gint index;
		index = 0;
		{
			gboolean _tmp5_;
			_tmp5_ = TRUE;
			while (TRUE) {
				gchar* _tmp6_;
				gchar* _tmp7_;
				gchar* _tmp8_;
				if (!_tmp5_) {
					index = index + 1;
				}
				_tmp5_ = FALSE;
				if (!(index < (paths_length1 - 2))) {
					break;
				}
				_tmp6_ = g_strconcat (paths[index], "/", NULL);
				_tmp7_ = _tmp6_;
				_tmp8_ = g_strconcat (folder_string, _tmp7_, NULL);
				_g_free0 (folder_string);
				folder_string = _tmp8_;
				_g_free0 (_tmp7_);
			}
		}
	}
	result = folder_string;
	paths = (_vala_array_free (paths, paths_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


gchar* beat_box_file_operator_find_album (BeatBoxFileOperator* self, BeatBoxSong* s) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* album_folder_string;
	GFile* _tmp2_ = NULL;
	GFile* album_folder;
	GFileInfo* file_info;
	GFileEnumerator* _tmp3_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	_tmp0_ = beat_box_song_get_file (s);
	_tmp1_ = beat_box_file_operator_get_folder (_tmp0_);
	album_folder_string = _tmp1_;
	_tmp2_ = g_file_new_for_path (album_folder_string);
	album_folder = _tmp2_;
	file_info = NULL;
	_tmp3_ = g_file_enumerate_children (album_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp3_;
	if (_inner_error_ != NULL) {
		goto __catch35_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp4_ = NULL;
		GFileInfo* _tmp5_;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_;
		const gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		gchar* _tmp12_;
		gchar* file_path;
		gboolean _tmp13_ = FALSE;
		gboolean _tmp14_ = FALSE;
		GFileType _tmp15_;
		_tmp4_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp5_ = _tmp4_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch35_g_error;
		}
		_g_object_unref0 (file_info);
		file_info = _tmp5_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp6_ = g_file_get_path (album_folder);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strconcat (_tmp7_, "/", NULL);
		_tmp9_ = _tmp8_;
		_tmp10_ = g_file_info_get_name (file_info);
		_tmp11_ = g_strconcat (_tmp9_, _tmp10_, NULL);
		_tmp12_ = _tmp11_;
		_g_free0 (_tmp9_);
		_g_free0 (_tmp7_);
		file_path = _tmp12_;
		_tmp15_ = g_file_info_get_file_type (file_info);
		if (_tmp15_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp16_ = NULL;
			gboolean _tmp17_;
			_tmp16_ = g_file_info_get_name (file_info);
			_tmp17_ = beat_box_file_operator_is_image_file_type (self, _tmp16_);
			_tmp14_ = _tmp17_;
		} else {
			_tmp14_ = FALSE;
		}
		if (_tmp14_) {
			const gchar* _tmp18_ = NULL;
			const gchar* _tmp19_ = NULL;
			gboolean _tmp20_;
			_tmp18_ = g_file_info_get_name (file_info);
			_tmp19_ = beat_box_song_get_album (s);
			_tmp20_ = string_contains (_tmp18_, _tmp19_);
			_tmp13_ = _tmp20_;
		} else {
			_tmp13_ = FALSE;
		}
		if (_tmp13_) {
			result = file_path;
			_g_object_unref0 (enumerator);
			_g_object_unref0 (file_info);
			_g_object_unref0 (album_folder);
			_g_free0 (album_folder_string);
			return result;
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally35;
	__catch35_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not find album artwork: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally35:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		_g_object_unref0 (album_folder);
		_g_free0 (album_folder_string);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	_g_object_unref0 (file_info);
	_g_object_unref0 (album_folder);
	_g_free0 (album_folder_string);
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GRegex* _tmp2_ = NULL;
	GRegex* _tmp3_;
	GRegex* regex;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	_tmp0_ = g_regex_escape_string (old, -1);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_regex_new (_tmp1_, 0, 0, &_inner_error_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	regex = _tmp3_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_REGEX_ERROR) {
			goto __catch37_g_regex_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
	_tmp5_ = _tmp4_;
	if (_inner_error_ != NULL) {
		_g_regex_unref0 (regex);
		if (_inner_error_->domain == G_REGEX_ERROR) {
			goto __catch37_g_regex_error;
		}
		_g_regex_unref0 (regex);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = _tmp5_;
	_g_regex_unref0 (regex);
	return result;
	_g_regex_unref0 (regex);
	goto __finally37;
	__catch37_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally37:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


GdkPixbuf* beat_box_file_operator_save_album (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* rv = NULL;
	gboolean _tmp0_ = FALSE;
	GFile* _tmp1_ = NULL;
	GFile* file;
	GFileInputStream* filestream = NULL;
	GFileInputStream* _tmp2_ = NULL;
	GFileInputStream* _tmp3_;
	GdkPixbuf* _tmp4_ = NULL;
	GdkPixbuf* _tmp5_;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	if (uri == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (uri, "") == 0;
	}
	if (_tmp0_) {
		result = NULL;
		_g_object_unref0 (rv);
		return result;
	}
	_tmp1_ = g_file_new_for_uri (uri);
	file = _tmp1_;
	if (file == NULL) {
		fprintf (stdout, "Could not access %s\n", uri);
		result = NULL;
		_g_object_unref0 (file);
		_g_object_unref0 (rv);
		return result;
	}
	_tmp2_ = g_file_read (file, NULL, &_inner_error_);
	_tmp3_ = _tmp2_;
	if (_inner_error_ != NULL) {
		goto __catch36_g_error;
	}
	_g_object_unref0 (filestream);
	filestream = _tmp3_;
	_tmp4_ = gdk_pixbuf_new_from_stream ((GInputStream*) filestream, NULL, &_inner_error_);
	_tmp5_ = _tmp4_;
	if (_inner_error_ != NULL) {
		goto __catch36_g_error;
	}
	_g_object_unref0 (rv);
	rv = _tmp5_;
	_tmp6_ = beat_box_song_get_file (s);
	_tmp7_ = beat_box_file_operator_get_folder (_tmp6_);
	_tmp8_ = _tmp7_;
	fprintf (stdout, "Saving to %s\n", _tmp8_);
	_g_free0 (_tmp8_);
	_tmp9_ = beat_box_song_get_file (s);
	_tmp10_ = beat_box_file_operator_get_folder (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = beat_box_song_get_album (s);
	_tmp13_ = string_replace (_tmp12_, "/", "_");
	_tmp14_ = _tmp13_;
	_tmp15_ = g_strconcat (_tmp11_, _tmp14_, NULL);
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strconcat (_tmp16_, ".jpg", NULL);
	_tmp18_ = _tmp17_;
	gdk_pixbuf_save (rv, _tmp18_, "jpeg", &_inner_error_, NULL);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp16_);
	_g_free0 (_tmp14_);
	_g_free0 (_tmp11_);
	if (_inner_error_ != NULL) {
		goto __catch36_g_error;
	}
	goto __finally36;
	__catch36_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not save album art from %s: %s\n", uri, err->message);
		_g_object_unref0 (rv);
		rv = NULL;
		_g_error_free0 (err);
	}
	__finally36:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (filestream);
		_g_object_unref0 (file);
		_g_object_unref0 (rv);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = rv;
	_g_object_unref0 (filestream);
	_g_object_unref0 (file);
	return result;
}


gchar* beat_box_file_operator_find_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* artist_folder_string;
	GFile* _tmp5_ = NULL;
	GFile* artist_folder;
	GFileInfo* file_info;
	GFileEnumerator* _tmp6_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	_tmp0_ = beat_box_song_get_file (s);
	_tmp1_ = beat_box_file_operator_get_folder (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = beat_box_file_operator_get_folder (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	artist_folder_string = _tmp4_;
	_tmp5_ = g_file_new_for_path (artist_folder_string);
	artist_folder = _tmp5_;
	file_info = NULL;
	_tmp6_ = g_file_enumerate_children (artist_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp6_;
	if (_inner_error_ != NULL) {
		goto __catch38_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp7_ = NULL;
		GFileInfo* _tmp8_;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		const gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		gchar* _tmp15_;
		gchar* file_path;
		gboolean _tmp16_ = FALSE;
		GFileType _tmp17_;
		_tmp7_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch38_g_error;
		}
		_g_object_unref0 (file_info);
		file_info = _tmp8_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp9_ = g_file_get_path (artist_folder);
		_tmp10_ = _tmp9_;
		_tmp11_ = g_strconcat (_tmp10_, "/", NULL);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_file_info_get_name (file_info);
		_tmp14_ = g_strconcat (_tmp12_, _tmp13_, NULL);
		_tmp15_ = _tmp14_;
		_g_free0 (_tmp12_);
		_g_free0 (_tmp10_);
		file_path = _tmp15_;
		_tmp17_ = g_file_info_get_file_type (file_info);
		if (_tmp17_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp18_ = NULL;
			gboolean _tmp19_;
			_tmp18_ = g_file_info_get_name (file_info);
			_tmp19_ = beat_box_file_operator_is_image_file_type (self, _tmp18_);
			_tmp16_ = _tmp19_;
		} else {
			_tmp16_ = FALSE;
		}
		if (_tmp16_) {
			result = file_path;
			_g_object_unref0 (enumerator);
			_g_object_unref0 (file_info);
			_g_object_unref0 (artist_folder);
			_g_free0 (artist_folder_string);
			return result;
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally38;
	__catch38_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not find artist image: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally38:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		_g_object_unref0 (artist_folder);
		_g_free0 (artist_folder_string);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	_g_object_unref0 (file_info);
	_g_object_unref0 (artist_folder);
	_g_free0 (artist_folder_string);
	return result;
}


GdkPixbuf* beat_box_file_operator_save_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* rv = NULL;
	gboolean _tmp0_ = FALSE;
	GFile* _tmp1_ = NULL;
	GFile* file;
	GFileInputStream* filestream = NULL;
	GFileInputStream* _tmp2_ = NULL;
	GFileInputStream* _tmp3_;
	GdkPixbuf* _tmp4_ = NULL;
	GdkPixbuf* _tmp5_;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	if (uri == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (uri, "") == 0;
	}
	if (_tmp0_) {
		result = NULL;
		_g_object_unref0 (rv);
		return result;
	}
	_tmp1_ = g_file_new_for_uri (uri);
	file = _tmp1_;
	_tmp2_ = g_file_read (file, NULL, &_inner_error_);
	_tmp3_ = _tmp2_;
	if (_inner_error_ != NULL) {
		goto __catch39_g_error;
	}
	_g_object_unref0 (filestream);
	filestream = _tmp3_;
	_tmp4_ = gdk_pixbuf_new_from_stream ((GInputStream*) filestream, NULL, &_inner_error_);
	_tmp5_ = _tmp4_;
	if (_inner_error_ != NULL) {
		goto __catch39_g_error;
	}
	_g_object_unref0 (rv);
	rv = _tmp5_;
	_tmp6_ = beat_box_song_get_file (s);
	_tmp7_ = beat_box_file_operator_get_folder (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = beat_box_file_operator_get_folder (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = beat_box_song_get_artist (s);
	_tmp12_ = g_strconcat (_tmp10_, _tmp11_, NULL);
	_tmp13_ = _tmp12_;
	_tmp14_ = g_strconcat (_tmp13_, ".jpg", NULL);
	_tmp15_ = _tmp14_;
	gdk_pixbuf_save (rv, _tmp15_, "jpeg", &_inner_error_, NULL);
	_g_free0 (_tmp15_);
	_g_free0 (_tmp13_);
	_g_free0 (_tmp10_);
	_g_free0 (_tmp8_);
	if (_inner_error_ != NULL) {
		goto __catch39_g_error;
	}
	goto __finally39;
	__catch39_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not save artist image from %s: %s\n", uri, err->message);
		_g_object_unref0 (rv);
		rv = NULL;
		_g_error_free0 (err);
	}
	__finally39:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (filestream);
		_g_object_unref0 (file);
		_g_object_unref0 (rv);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = rv;
	_g_object_unref0 (filestream);
	_g_object_unref0 (file);
	return result;
}


static gpointer _beat_box_file_operator_save_song_thread_gthread_func (gpointer self) {
	gpointer result;
	result = beat_box_file_operator_save_song_thread (self);
	return result;
}


void beat_box_file_operator_save_songs (BeatBoxFileOperator* self, GeeCollection* to_save) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (to_save != NULL);
	{
		GeeIterator* _tmp0_ = NULL;
		GeeIterator* _s_it;
		_tmp0_ = gee_iterable_iterator ((GeeIterable*) to_save);
		_s_it = _tmp0_;
		while (TRUE) {
			gboolean _tmp1_;
			gpointer _tmp2_ = NULL;
			BeatBoxSong* s;
			gboolean _tmp3_;
			_tmp1_ = gee_iterator_next (_s_it);
			if (!_tmp1_) {
				break;
			}
			_tmp2_ = gee_iterator_get (_s_it);
			s = (BeatBoxSong*) _tmp2_;
			_tmp3_ = gee_abstract_collection_contains ((GeeAbstractCollection*) self->priv->toSave, s);
			if (!_tmp3_) {
				gee_queue_offer ((GeeQueue*) self->priv->toSave, s);
			}
			_g_object_unref0 (s);
		}
		_g_object_unref0 (_s_it);
	}
	if (!self->priv->inThread) {
		self->priv->inThread = TRUE;
		g_thread_create (_beat_box_file_operator_save_song_thread_gthread_func, self, FALSE, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch40_g_error;
		}
		goto __finally40;
		__catch40_g_error:
		{
			GError * err;
			err = _inner_error_;
			_inner_error_ = NULL;
			fprintf (stdout, "Could not create thread to rescan music folder: %s\n", err->message);
			_g_error_free0 (err);
		}
		__finally40:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


void* beat_box_file_operator_save_song_thread (BeatBoxFileOperator* self) {
	void* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	while (TRUE) {
		gpointer _tmp0_ = NULL;
		BeatBoxSong* s;
		TagLib_File* tag_file = NULL;
		const gchar* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		TagLib_File* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp23_;
		_tmp0_ = gee_queue_poll ((GeeQueue*) self->priv->toSave);
		s = (BeatBoxSong*) _tmp0_;
		if (s == NULL) {
			self->priv->inThread = FALSE;
			result = NULL;
			_g_object_unref0 (s);
			return result;
		}
		_tmp1_ = beat_box_song_get_file (s);
		fprintf (stdout, "Saving file %s \n", _tmp1_);
		_tmp2_ = beat_box_song_get_file (s);
		_tmp3_ = taglib_file_new (_tmp2_);
		_taglib_file_free0 (tag_file);
		tag_file = _tmp3_;
		if (tag_file != NULL) {
			TagLib_Tag* _tmp6_ = NULL;
			_tmp6_ = taglib_file_tag (tag_file);
			_tmp5_ = _tmp6_ != NULL;
		} else {
			_tmp5_ = FALSE;
		}
		if (_tmp5_) {
			const TagLib_AudioProperties* _tmp7_ = NULL;
			_tmp7_ = taglib_file_audioproperties (tag_file);
			_tmp4_ = _tmp7_ != NULL;
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			TagLib_Tag* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			TagLib_Tag* _tmp10_ = NULL;
			const gchar* _tmp11_ = NULL;
			TagLib_Tag* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			TagLib_Tag* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			TagLib_Tag* _tmp16_ = NULL;
			const gchar* _tmp17_ = NULL;
			TagLib_Tag* _tmp18_ = NULL;
			gint _tmp19_;
			TagLib_Tag* _tmp20_ = NULL;
			gint _tmp21_;
			_tmp8_ = taglib_file_tag (tag_file);
			_tmp9_ = beat_box_song_get_title (s);
			taglib_tag_set_title (_tmp8_, _tmp9_);
			_tmp10_ = taglib_file_tag (tag_file);
			_tmp11_ = beat_box_song_get_artist (s);
			taglib_tag_set_artist (_tmp10_, _tmp11_);
			_tmp12_ = taglib_file_tag (tag_file);
			_tmp13_ = beat_box_song_get_album (s);
			taglib_tag_set_album (_tmp12_, _tmp13_);
			_tmp14_ = taglib_file_tag (tag_file);
			_tmp15_ = beat_box_song_get_genre (s);
			taglib_tag_set_genre (_tmp14_, _tmp15_);
			_tmp16_ = taglib_file_tag (tag_file);
			_tmp17_ = beat_box_song_get_comment (s);
			taglib_tag_set_comment (_tmp16_, _tmp17_);
			_tmp18_ = taglib_file_tag (tag_file);
			_tmp19_ = beat_box_song_get_year (s);
			taglib_tag_set_year (_tmp18_, (guint) _tmp19_);
			_tmp20_ = taglib_file_tag (tag_file);
			_tmp21_ = beat_box_song_get_track (s);
			taglib_tag_set_track (_tmp20_, (guint) _tmp21_);
			taglib_file_save (tag_file);
			__finally41:
			if (_inner_error_ != NULL) {
				_taglib_file_free0 (tag_file);
				_g_object_unref0 (s);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		} else {
			const gchar* _tmp22_ = NULL;
			_tmp22_ = beat_box_song_get_file (s);
			fprintf (stdout, "Could not save %s.\n", _tmp22_);
		}
		_tmp23_ = beat_box_settings_getUpdateFolderHierarchy (self->priv->settings);
		if (_tmp23_) {
			beat_box_file_operator_update_file_hierarchy (self, s, TRUE);
		}
		_taglib_file_free0 (tag_file);
		_g_object_unref0 (s);
	}
}


void beat_box_file_operator_update_file_hierarchy (BeatBoxFileOperator* self, BeatBoxSong* s, gboolean delete_old) {
	const gchar* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFile* original;
	GFileInfo* _tmp2_ = NULL;
	GFileInfo* file_info;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	const gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	gchar* _tmp19_;
	gchar* _tmp20_;
	const gchar* _tmp21_ = NULL;
	gchar* _tmp22_;
	gchar* _tmp23_;
	GFile* _tmp24_ = NULL;
	GFile* _tmp25_;
	GFile* dest;
	gchar* _tmp26_ = NULL;
	gchar* _tmp27_;
	gchar* _tmp28_ = NULL;
	gchar* _tmp29_;
	gboolean _tmp30_;
	GFile* _tmp31_ = NULL;
	GFile* _tmp32_;
	GFile* _tmp33_ = NULL;
	GFile* _tmp34_;
	gboolean _tmp35_;
	gboolean _tmp36_;
	gboolean success;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (s != NULL);
	_tmp0_ = beat_box_song_get_file (s);
	_tmp1_ = g_file_new_for_path (_tmp0_);
	original = _tmp1_;
	_tmp2_ = g_file_query_info (original, "*", G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
	file_info = _tmp2_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (original);
		goto __catch42_g_error;
	}
	_tmp3_ = beat_box_settings_getMusicFolder (self->priv->settings);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat (_tmp4_, "/", NULL);
	_tmp6_ = _tmp5_;
	_tmp7_ = beat_box_song_get_artist (s);
	_tmp8_ = string_replace (_tmp7_, "/", "_");
	_tmp9_ = _tmp8_;
	_tmp10_ = g_strconcat (_tmp6_, _tmp9_, NULL);
	_tmp11_ = _tmp10_;
	_tmp12_ = g_strconcat (_tmp11_, "/", NULL);
	_tmp13_ = _tmp12_;
	_tmp14_ = beat_box_song_get_album (s);
	_tmp15_ = string_replace (_tmp14_, "/", "_");
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strconcat (_tmp13_, _tmp16_, NULL);
	_tmp18_ = _tmp17_;
	_tmp19_ = g_strconcat (_tmp18_, "/", NULL);
	_tmp20_ = _tmp19_;
	_tmp21_ = g_file_info_get_name (file_info);
	_tmp22_ = g_strconcat (_tmp20_, _tmp21_, NULL);
	_tmp23_ = _tmp22_;
	_tmp24_ = g_file_new_for_path (_tmp23_);
	_tmp25_ = _tmp24_;
	_g_free0 (_tmp23_);
	_g_free0 (_tmp20_);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp16_);
	_g_free0 (_tmp13_);
	_g_free0 (_tmp11_);
	_g_free0 (_tmp9_);
	_g_free0 (_tmp6_);
	_g_free0 (_tmp4_);
	dest = _tmp25_;
	_tmp26_ = g_file_get_path (original);
	_tmp27_ = _tmp26_;
	_tmp28_ = g_file_get_path (dest);
	_tmp29_ = _tmp28_;
	_tmp30_ = g_strcmp0 (_tmp27_, _tmp29_) == 0;
	_g_free0 (_tmp29_);
	_g_free0 (_tmp27_);
	if (_tmp30_) {
		_g_object_unref0 (dest);
		_g_object_unref0 (file_info);
		_g_object_unref0 (original);
		return;
	}
	_tmp31_ = g_file_get_parent (dest);
	_tmp32_ = _tmp31_;
	_tmp33_ = g_file_get_parent (_tmp32_);
	_tmp34_ = _tmp33_;
	_tmp35_ = g_file_query_exists (_tmp34_, NULL);
	_tmp36_ = !_tmp35_;
	_g_object_unref0 (_tmp34_);
	_g_object_unref0 (_tmp32_);
	if (_tmp36_) {
		GFile* _tmp37_ = NULL;
		GFile* _tmp38_;
		GFile* _tmp39_ = NULL;
		GFile* _tmp40_;
		gchar* _tmp41_ = NULL;
		gchar* _tmp42_;
		GFile* _tmp43_ = NULL;
		GFile* _tmp44_;
		GFile* _tmp45_ = NULL;
		GFile* _tmp46_;
		GFile* _tmp47_ = NULL;
		GFile* _tmp48_;
		_tmp37_ = g_file_get_parent (dest);
		_tmp38_ = _tmp37_;
		_tmp39_ = g_file_get_parent (_tmp38_);
		_tmp40_ = _tmp39_;
		_tmp41_ = g_file_get_path (_tmp40_);
		_tmp42_ = _tmp41_;
		fprintf (stdout, "artist folder %s does not exist\n", _tmp42_);
		_g_free0 (_tmp42_);
		_g_object_unref0 (_tmp40_);
		_g_object_unref0 (_tmp38_);
		_tmp43_ = g_file_get_parent (dest);
		_tmp44_ = _tmp43_;
		_tmp45_ = g_file_get_parent (_tmp44_);
		_tmp46_ = _tmp45_;
		g_file_make_directory (_tmp46_, NULL, &_inner_error_);
		_g_object_unref0 (_tmp46_);
		_g_object_unref0 (_tmp44_);
		if (_inner_error_ != NULL) {
			goto __catch43_g_error;
		}
		_tmp47_ = g_file_get_parent (dest);
		_tmp48_ = _tmp47_;
		g_file_make_directory (_tmp48_, NULL, &_inner_error_);
		_g_object_unref0 (_tmp48_);
		if (_inner_error_ != NULL) {
			goto __catch43_g_error;
		}
		goto __finally43;
		__catch43_g_error:
		{
			GError * err;
			err = _inner_error_;
			_inner_error_ = NULL;
			fprintf (stdout, "Could not create folder to copy to: %s\n", err->message);
			_g_error_free0 (err);
		}
		__finally43:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (dest);
			_g_object_unref0 (file_info);
			_g_object_unref0 (original);
			goto __catch42_g_error;
		}
	} else {
		GFile* _tmp49_ = NULL;
		GFile* _tmp50_;
		gboolean _tmp51_;
		gboolean _tmp52_;
		_tmp49_ = g_file_get_parent (dest);
		_tmp50_ = _tmp49_;
		_tmp51_ = g_file_query_exists (_tmp50_, NULL);
		_tmp52_ = !_tmp51_;
		_g_object_unref0 (_tmp50_);
		if (_tmp52_) {
			GFile* _tmp53_ = NULL;
			GFile* _tmp54_;
			gchar* _tmp55_ = NULL;
			gchar* _tmp56_;
			GFile* _tmp57_ = NULL;
			GFile* _tmp58_;
			_tmp53_ = g_file_get_parent (dest);
			_tmp54_ = _tmp53_;
			_tmp55_ = g_file_get_path (_tmp54_);
			_tmp56_ = _tmp55_;
			fprintf (stdout, "album folder %s does not exist\n", _tmp56_);
			_g_free0 (_tmp56_);
			_g_object_unref0 (_tmp54_);
			_tmp57_ = g_file_get_parent (dest);
			_tmp58_ = _tmp57_;
			g_file_make_directory (_tmp58_, NULL, &_inner_error_);
			_g_object_unref0 (_tmp58_);
			if (_inner_error_ != NULL) {
				goto __catch44_g_error;
			}
			goto __finally44;
			__catch44_g_error:
			{
				GError * err;
				err = _inner_error_;
				_inner_error_ = NULL;
				fprintf (stdout, "Could not create folder to copy to: %s\n", err->message);
				_g_error_free0 (err);
			}
			__finally44:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (dest);
				_g_object_unref0 (file_info);
				_g_object_unref0 (original);
				goto __catch42_g_error;
			}
		}
	}
	success = FALSE;
	if (!delete_old) {
		const gchar* _tmp59_ = NULL;
		gchar* _tmp60_ = NULL;
		gchar* _tmp61_;
		gboolean _tmp62_;
		gboolean _tmp63_;
		_tmp59_ = beat_box_song_get_file (s);
		_tmp60_ = g_file_get_path (dest);
		_tmp61_ = _tmp60_;
		fprintf (stdout, "Copying %s to %s\n", _tmp59_, _tmp61_);
		_g_free0 (_tmp61_);
		_tmp62_ = g_file_copy (original, dest, G_FILE_COPY_NONE, NULL, NULL, NULL, &_inner_error_);
		_tmp63_ = _tmp62_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (dest);
			_g_object_unref0 (file_info);
			_g_object_unref0 (original);
			goto __catch42_g_error;
		}
		success = _tmp63_;
	} else {
		const gchar* _tmp64_ = NULL;
		gchar* _tmp65_ = NULL;
		gchar* _tmp66_;
		gboolean _tmp67_;
		gboolean _tmp68_;
		_tmp64_ = beat_box_song_get_file (s);
		_tmp65_ = g_file_get_path (dest);
		_tmp66_ = _tmp65_;
		fprintf (stdout, "Moving %s to %s\n", _tmp64_, _tmp66_);
		_g_free0 (_tmp66_);
		_tmp67_ = g_file_move (original, dest, G_FILE_COPY_NONE, NULL, NULL, NULL, &_inner_error_);
		_tmp68_ = _tmp67_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (dest);
			_g_object_unref0 (file_info);
			_g_object_unref0 (original);
			goto __catch42_g_error;
		}
		success = _tmp68_;
	}
	if (success) {
		gchar* _tmp69_ = NULL;
		gchar* _tmp70_;
		_tmp69_ = g_file_get_path (dest);
		_tmp70_ = _tmp69_;
		beat_box_song_set_file (s, _tmp70_);
		_g_free0 (_tmp70_);
	} else {
		const gchar* _tmp71_ = NULL;
		gchar* _tmp72_ = NULL;
		gchar* _tmp73_;
		_tmp71_ = beat_box_song_get_file (s);
		_tmp72_ = g_file_get_path (dest);
		_tmp73_ = _tmp72_;
		fprintf (stdout, "Failure: Could not copy imported song %s to media folder %s\n", _tmp71_, _tmp73_);
		_g_free0 (_tmp73_);
	}
	if (delete_old) {
		GFile* _tmp74_ = NULL;
		GFile* _tmp75_;
		gint _tmp76_;
		gint _tmp77_;
		gint old_folder_items;
		_tmp74_ = g_file_get_parent (original);
		_tmp75_ = _tmp74_;
		_tmp76_ = beat_box_file_operator_count_music_files (self, _tmp75_);
		_tmp77_ = _tmp76_;
		_g_object_unref0 (_tmp75_);
		old_folder_items = _tmp77_;
		if (old_folder_items == 0) {
			GFile* _tmp78_ = NULL;
			GFile* _tmp79_;
			gchar* _tmp80_ = NULL;
			gchar* _tmp81_;
			GFile* _tmp82_ = NULL;
			GFile* _tmp83_;
			_tmp78_ = g_file_get_parent (original);
			_tmp79_ = _tmp78_;
			_tmp80_ = g_file_get_path (_tmp79_);
			_tmp81_ = _tmp80_;
			fprintf (stdout, "going to delete %s because no files are in it\n", _tmp81_);
			_g_free0 (_tmp81_);
			_g_object_unref0 (_tmp79_);
			_tmp82_ = g_file_get_parent (original);
			_tmp83_ = _tmp82_;
			g_file_delete (_tmp83_, NULL, &_inner_error_);
			_g_object_unref0 (_tmp83_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (dest);
				_g_object_unref0 (file_info);
				_g_object_unref0 (original);
				goto __catch42_g_error;
			}
		}
	}
	_g_object_unref0 (dest);
	_g_object_unref0 (file_info);
	_g_object_unref0 (original);
	goto __finally42;
	__catch42_g_error:
	{
		GError * err;
		const gchar* _tmp84_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp84_ = beat_box_song_get_file (s);
		fprintf (stdout, "Could not copy imported song %s to media folder: %s\n", _tmp84_, err->message);
		_g_error_free0 (err);
	}
	__finally42:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void beat_box_file_operator_remove_songs (BeatBoxFileOperator* self, GeeCollection* toRemove) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (toRemove != NULL);
	{
		GeeIterator* _tmp0_ = NULL;
		GeeIterator* _s_it;
		_tmp0_ = gee_iterable_iterator ((GeeIterable*) toRemove);
		_s_it = _tmp0_;
		while (TRUE) {
			gboolean _tmp1_;
			gpointer _tmp2_ = NULL;
			gchar* s;
			GFile* _tmp3_ = NULL;
			GFile* file;
			GFile* _tmp4_ = NULL;
			GFile* _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			gint old_folder_items;
			_tmp1_ = gee_iterator_next (_s_it);
			if (!_tmp1_) {
				break;
			}
			_tmp2_ = gee_iterator_get (_s_it);
			s = (gchar*) _tmp2_;
			_tmp3_ = g_file_new_for_path (s);
			file = _tmp3_;
			g_file_trash (file, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (file);
				goto __catch45_g_error;
			}
			_tmp4_ = g_file_get_parent (file);
			_tmp5_ = _tmp4_;
			_tmp6_ = beat_box_file_operator_count_music_files (self, _tmp5_);
			_tmp7_ = _tmp6_;
			_g_object_unref0 (_tmp5_);
			old_folder_items = _tmp7_;
			if (old_folder_items == 0) {
				GFile* _tmp8_ = NULL;
				GFile* _tmp9_;
				gchar* _tmp10_ = NULL;
				gchar* _tmp11_;
				GFile* _tmp12_ = NULL;
				GFile* _tmp13_;
				GFile* _tmp14_ = NULL;
				GFile* _tmp15_;
				gint _tmp16_;
				gint _tmp17_;
				gint old_folder_parent_items;
				_tmp8_ = g_file_get_parent (file);
				_tmp9_ = _tmp8_;
				_tmp10_ = g_file_get_path (_tmp9_);
				_tmp11_ = _tmp10_;
				fprintf (stdout, "going to delete %s because no files are in it\n", _tmp11_);
				_g_free0 (_tmp11_);
				_g_object_unref0 (_tmp9_);
				_tmp12_ = g_file_get_parent (file);
				_tmp13_ = _tmp12_;
				_tmp14_ = g_file_get_parent (_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = beat_box_file_operator_count_music_files (self, _tmp15_);
				_tmp17_ = _tmp16_;
				_g_object_unref0 (_tmp15_);
				_g_object_unref0 (_tmp13_);
				old_folder_parent_items = _tmp17_;
				if (old_folder_parent_items == 0) {
					GFile* _tmp18_ = NULL;
					GFile* _tmp19_;
					GFile* _tmp20_ = NULL;
					GFile* _tmp21_;
					gchar* _tmp22_ = NULL;
					gchar* _tmp23_;
					_tmp18_ = g_file_get_parent (file);
					_tmp19_ = _tmp18_;
					_tmp20_ = g_file_get_parent (_tmp19_);
					_tmp21_ = _tmp20_;
					_tmp22_ = g_file_get_path (_tmp21_);
					_tmp23_ = _tmp22_;
					fprintf (stdout, "going to delete %s because no files are in it\n", _tmp23_);
					_g_free0 (_tmp23_);
					_g_object_unref0 (_tmp21_);
					_g_object_unref0 (_tmp19_);
				}
			}
			_g_object_unref0 (file);
			goto __finally45;
			__catch45_g_error:
			{
				GError * err;
				GtkMessageDialog* _tmp24_ = NULL;
				GtkMessageDialog* md;
				err = _inner_error_;
				_inner_error_ = NULL;
				fprintf (stdout, "Could not move file %s to trash: %s (you could be using a file system " \
"which is not supported)\n", s, err->message);
				_tmp24_ = (GtkMessageDialog*) gtk_message_dialog_new ((GtkWindow*) self->priv->lm->lw, GTK_DIALOG_MODAL, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, "Could not trash file %s, would you like to permanently delete it? You " \
"cannot undo these changes.", s);
				md = g_object_ref_sink (_tmp24_);
				_g_object_unref0 (md);
				_g_error_free0 (err);
			}
			__finally45:
			if (_inner_error_ != NULL) {
				_g_free0 (s);
				_g_object_unref0 (_s_it);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_g_free0 (s);
		}
		_g_object_unref0 (_s_it);
	}
}


static void g_cclosure_user_marshal_VOID__STRING_DOUBLE (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_DOUBLE) (gpointer data1, const char* arg_1, gdouble arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_DOUBLE callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_DOUBLE) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_double (param_values + 2), data2);
}


static void beat_box_file_operator_class_init (BeatBoxFileOperatorClass * klass) {
	beat_box_file_operator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BeatBoxFileOperatorPrivate));
	G_OBJECT_CLASS (klass)->finalize = beat_box_file_operator_finalize;
	g_signal_new ("fo_progress", BEAT_BOX_TYPE_FILE_OPERATOR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_DOUBLE, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_DOUBLE);
}


static void beat_box_file_operator_instance_init (BeatBoxFileOperator * self) {
	self->priv = BEAT_BOX_FILE_OPERATOR_GET_PRIVATE (self);
}


static void beat_box_file_operator_finalize (GObject* obj) {
	BeatBoxFileOperator * self;
	self = BEAT_BOX_FILE_OPERATOR (obj);
	_g_object_unref0 (self->priv->lm);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->toSave);
	G_OBJECT_CLASS (beat_box_file_operator_parent_class)->finalize (obj);
}


GType beat_box_file_operator_get_type (void) {
	static volatile gsize beat_box_file_operator_type_id__volatile = 0;
	if (g_once_init_enter (&beat_box_file_operator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BeatBoxFileOperatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beat_box_file_operator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BeatBoxFileOperator), 0, (GInstanceInitFunc) beat_box_file_operator_instance_init, NULL };
		GType beat_box_file_operator_type_id;
		beat_box_file_operator_type_id = g_type_register_static (G_TYPE_OBJECT, "BeatBoxFileOperator", &g_define_type_info, 0);
		g_once_init_leave (&beat_box_file_operator_type_id__volatile, beat_box_file_operator_type_id);
	}
	return beat_box_file_operator_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



