/* Settings.c generated by valac 0.11.5, the Vala compiler
 * generated from Settings.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gconf/gconf-client.h>
#include <stdlib.h>
#include <string.h>
#include <gconf/gconf.h>
#include <stdio.h>
#include <gee.h>


#define BEAT_BOX_TYPE_SETTINGS (beat_box_settings_get_type ())
#define BEAT_BOX_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettings))
#define BEAT_BOX_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettingsClass))
#define BEAT_BOX_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_SETTINGS))
#define BEAT_BOX_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_SETTINGS))
#define BEAT_BOX_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettingsClass))

typedef struct _BeatBoxSettings BeatBoxSettings;
typedef struct _BeatBoxSettingsClass BeatBoxSettingsClass;
typedef struct _BeatBoxSettingsPrivate BeatBoxSettingsPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gconf_value_free0(var) ((var == NULL) ? NULL : (var = (gconf_value_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _BeatBoxSettings {
	GObject parent_instance;
	BeatBoxSettingsPrivate * priv;
};

struct _BeatBoxSettingsClass {
	GObjectClass parent_class;
};

struct _BeatBoxSettingsPrivate {
	GConfClient* client;
};


static gpointer beat_box_settings_parent_class = NULL;

GType beat_box_settings_get_type (void) G_GNUC_CONST;
#define BEAT_BOX_SETTINGS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettingsPrivate))
enum  {
	BEAT_BOX_SETTINGS_DUMMY_PROPERTY
};
#define BEAT_BOX_SETTINGS_LASTFM_USERNAME "/apps/beatbox/preferences/lastfm/username"
#define BEAT_BOX_SETTINGS_LASTFM_PASSWORD "/apps/beatbox/preferences/lastfm/pass"
#define BEAT_BOX_SETTINGS_LASTFM_AUTO_LOGIN "/apps/beatbox/preferences/lastfm/auto_login"
#define BEAT_BOX_SETTINGS_LASTFM_SESSION_KEY "/apps/beatbox/preferences/lastfm/lastfm_session_key"
#define BEAT_BOX_SETTINGS_MUSIC_FOLDERS "/apps/beatbox/preferences/music/music_locations"
#define BEAT_BOX_SETTINGS_UPDATE_FOLDER_HIERARCHY "/apps/beatbox/preferences/music/update_folder_hierarchy"
#define BEAT_BOX_SETTINGS_COPY_IMPORTED_MUSIC "/apps/beatbox/preferences/music/copy_imported_music"
#define BEAT_BOX_SETTINGS_WINDOW_MAXIMIZED "/apps/beatbox/preferences/ui/window_maximized"
#define BEAT_BOX_SETTINGS_WINDOW_WIDTH "/apps/beatbox/preferences/ui/window_width"
#define BEAT_BOX_SETTINGS_WINDOW_HEIGHT "/apps/beatbox/preferences/ui/window_height"
#define BEAT_BOX_SETTINGS_SIDEBAR_WIDTH "/apps/beatbox/preferences/ui/sidebar_width"
BeatBoxSettings* beat_box_settings_new (void);
BeatBoxSettings* beat_box_settings_construct (GType object_type);
static gboolean beat_box_settings_getBool (BeatBoxSettings* self, const gchar* path, gboolean def);
static gchar* beat_box_settings_getString (BeatBoxSettings* self, const gchar* path, const gchar* def);
static gint beat_box_settings_getInt (BeatBoxSettings* self, const gchar* path, gint def);
static void beat_box_settings_setBool (BeatBoxSettings* self, const gchar* path, gboolean val);
static void beat_box_settings_setString (BeatBoxSettings* self, const gchar* path, const gchar* val);
static void beat_box_settings_setInt (BeatBoxSettings* self, const gchar* path, gint val);
gchar* beat_box_settings_getMusicFolders (BeatBoxSettings* self);
GeeLinkedList* beat_box_settings_getMusicFoldersList (BeatBoxSettings* self);
gboolean beat_box_settings_getWindowMaximized (BeatBoxSettings* self);
gint beat_box_settings_getWindowWidth (BeatBoxSettings* self);
gint beat_box_settings_getWindowHeight (BeatBoxSettings* self);
gint beat_box_settings_getSidebarWidth (BeatBoxSettings* self);
gboolean beat_box_settings_getUpdateFolderHierarchy (BeatBoxSettings* self);
gboolean beat_box_settings_getCopyImportedMusic (BeatBoxSettings* self);
gchar* beat_box_settings_getLastFMUsername (BeatBoxSettings* self);
gchar* beat_box_settings_getLastFMPassword (BeatBoxSettings* self);
gboolean beat_box_settings_getLastFMAutoLogin (BeatBoxSettings* self);
gchar* beat_box_settings_getLastFMSessionKey (BeatBoxSettings* self);
void beat_box_settings_setMusicFolders (BeatBoxSettings* self, const gchar* path);
void beat_box_settings_setMusicFoldersFromList (BeatBoxSettings* self, GeeLinkedList* locations);
void beat_box_settings_setWindowMaximized (BeatBoxSettings* self, gboolean val);
void beat_box_settings_setWindowWidth (BeatBoxSettings* self, gint val);
void beat_box_settings_setWindowHeight (BeatBoxSettings* self, gint val);
void beat_box_settings_setSidebarWidth (BeatBoxSettings* self, gint val);
void beat_box_settings_setUpdateFolderHierarchy (BeatBoxSettings* self, gboolean val);
void beat_box_settings_setCopyImportedMusic (BeatBoxSettings* self, gboolean val);
void beat_box_settings_setLastFMUsername (BeatBoxSettings* self, const gchar* val);
void beat_box_settings_setLastFMPassword (BeatBoxSettings* self, const gchar* val);
void beat_box_settings_setLastFMAutoLogin (BeatBoxSettings* self, gboolean val);
void beat_box_settings_setLastFMSessionKey (BeatBoxSettings* self, const gchar* val);
static void beat_box_settings_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


BeatBoxSettings* beat_box_settings_construct (GType object_type) {
	BeatBoxSettings * self = NULL;
	GConfClient* _tmp0_ = NULL;
	GConfClient* _tmp1_;
	GConfClient* _tmp2_;
	self = (BeatBoxSettings*) g_object_new (object_type, NULL);
	_tmp0_ = gconf_client_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_tmp2_ = _tmp1_;
	_g_object_unref0 (self->priv->client);
	self->priv->client = _tmp2_;
	return self;
}


BeatBoxSettings* beat_box_settings_new (void) {
	return beat_box_settings_construct (BEAT_BOX_TYPE_SETTINGS);
}


static gboolean beat_box_settings_getBool (BeatBoxSettings* self, const gchar* path, gboolean def) {
	gboolean result = FALSE;
	gboolean rv;
	GConfValue* _tmp0_ = NULL;
	GConfValue* _tmp1_;
	GConfValue* _tmp2_;
	gboolean _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	rv = def;
	_tmp0_ = gconf_client_get (self->priv->client, path, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch32_g_error;
	}
	_tmp2_ = _tmp1_;
	if ((_tmp3_ = _tmp2_ != NULL, _gconf_value_free0 (_tmp2_), _tmp3_)) {
		gboolean _tmp4_;
		gboolean _tmp5_;
		_tmp4_ = gconf_client_get_bool (self->priv->client, path, &_inner_error_);
		_tmp5_ = _tmp4_;
		if (_inner_error_ != NULL) {
			goto __catch32_g_error;
		}
		rv = _tmp5_;
	} else {
		rv = def;
	}
	goto __finally32;
	__catch32_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not get bool value %s from gconf: %s\n", path, err->message);
		_g_error_free0 (err);
	}
	__finally32:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = rv;
	return result;
}


static gchar* beat_box_settings_getString (BeatBoxSettings* self, const gchar* path, const gchar* def) {
	gchar* result = NULL;
	gchar* _tmp0_;
	gchar* rv;
	GConfValue* _tmp1_ = NULL;
	GConfValue* _tmp2_;
	GConfValue* _tmp3_;
	gboolean _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (def != NULL, NULL);
	_tmp0_ = g_strdup (def);
	rv = _tmp0_;
	_tmp1_ = gconf_client_get (self->priv->client, path, &_inner_error_);
	_tmp2_ = _tmp1_;
	if (_inner_error_ != NULL) {
		goto __catch33_g_error;
	}
	_tmp3_ = _tmp2_;
	if ((_tmp4_ = _tmp3_ != NULL, _gconf_value_free0 (_tmp3_), _tmp4_)) {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		gchar* _tmp7_;
		_tmp5_ = gconf_client_get_string (self->priv->client, path, &_inner_error_);
		_tmp6_ = _tmp5_;
		if (_inner_error_ != NULL) {
			goto __catch33_g_error;
		}
		_tmp7_ = _tmp6_;
		_g_free0 (rv);
		rv = _tmp7_;
	} else {
		gchar* _tmp8_;
		gchar* _tmp9_;
		_tmp8_ = g_strdup (def);
		_tmp9_ = _tmp8_;
		_g_free0 (rv);
		rv = _tmp9_;
	}
	goto __finally33;
	__catch33_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not get string value %s from gconf: %s\n", path, err->message);
		_g_error_free0 (err);
	}
	__finally33:
	if (_inner_error_ != NULL) {
		_g_free0 (rv);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = rv;
	return result;
}


static gint beat_box_settings_getInt (BeatBoxSettings* self, const gchar* path, gint def) {
	gint result = 0;
	gint rv;
	GConfValue* _tmp0_ = NULL;
	GConfValue* _tmp1_;
	GConfValue* _tmp2_;
	gboolean _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (path != NULL, 0);
	rv = def;
	_tmp0_ = gconf_client_get (self->priv->client, path, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch34_g_error;
	}
	_tmp2_ = _tmp1_;
	if ((_tmp3_ = _tmp2_ != NULL, _gconf_value_free0 (_tmp2_), _tmp3_)) {
		gint _tmp4_;
		gint _tmp5_;
		_tmp4_ = gconf_client_get_int (self->priv->client, path, &_inner_error_);
		_tmp5_ = _tmp4_;
		if (_inner_error_ != NULL) {
			goto __catch34_g_error;
		}
		rv = _tmp5_;
	} else {
		rv = def;
	}
	goto __finally34;
	__catch34_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not get int value %s from gconf: %s\n", path, err->message);
		_g_error_free0 (err);
	}
	__finally34:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = rv;
	return result;
}


static void beat_box_settings_setBool (BeatBoxSettings* self, const gchar* path, gboolean val) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	gconf_client_set_bool (self->priv->client, path, val, &_inner_error_);
	if (_inner_error_ != NULL) {
		goto __catch35_g_error;
	}
	goto __finally35;
	__catch35_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not set bool value %s from gconf: %s\n", path, err->message);
		_g_error_free0 (err);
	}
	__finally35:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void beat_box_settings_setString (BeatBoxSettings* self, const gchar* path, const gchar* val) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	g_return_if_fail (val != NULL);
	gconf_client_set_string (self->priv->client, path, val, &_inner_error_);
	if (_inner_error_ != NULL) {
		goto __catch36_g_error;
	}
	goto __finally36;
	__catch36_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not set string value %s from gconf: %s\n", path, err->message);
		_g_error_free0 (err);
	}
	__finally36:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void beat_box_settings_setInt (BeatBoxSettings* self, const gchar* path, gint val) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	gconf_client_set_int (self->priv->client, path, val, &_inner_error_);
	if (_inner_error_ != NULL) {
		goto __catch37_g_error;
	}
	goto __finally37;
	__catch37_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not set int value %s from gconf: %s\n", path, err->message);
		_g_error_free0 (err);
	}
	__finally37:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


/** Get values **/
gchar* beat_box_settings_getMusicFolders (BeatBoxSettings* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = beat_box_settings_getString (self, BEAT_BOX_SETTINGS_MUSIC_FOLDERS, "");
	result = _tmp0_;
	return result;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


GeeLinkedList* beat_box_settings_getMusicFoldersList (BeatBoxSettings* self) {
	GeeLinkedList* result = NULL;
	GeeLinkedList* _tmp0_ = NULL;
	GeeLinkedList* rv;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_;
	gchar** locations;
	gint locations_length1;
	gint _locations_size_;
	gint index = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gee_linked_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	rv = _tmp0_;
	_tmp1_ = beat_box_settings_getMusicFolders (self);
	_tmp2_ = _tmp1_;
	_tmp4_ = _tmp3_ = g_strsplit (_tmp2_, "<location_seperator>", 0);
	locations = (_tmp5_ = _tmp4_, _g_free0 (_tmp2_), _tmp5_);
	locations_length1 = _vala_array_length (_tmp3_);
	_locations_size_ = _vala_array_length (_tmp3_);
	{
		gboolean _tmp6_;
		index = 0;
		_tmp6_ = TRUE;
		while (TRUE) {
			gboolean _tmp7_;
			if (!_tmp6_) {
				index = index + 1;
			}
			_tmp6_ = FALSE;
			if (!(index < (locations_length1 - 1))) {
				break;
			}
			_tmp7_ = string_contains (locations[index], "/");
			if (_tmp7_) {
				gee_abstract_collection_add ((GeeAbstractCollection*) rv, locations[index]);
			}
		}
	}
	result = rv;
	locations = (_vala_array_free (locations, locations_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


gboolean beat_box_settings_getWindowMaximized (BeatBoxSettings* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = beat_box_settings_getBool (self, BEAT_BOX_SETTINGS_WINDOW_MAXIMIZED, FALSE);
	result = _tmp0_;
	return result;
}


gint beat_box_settings_getWindowWidth (BeatBoxSettings* self) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = beat_box_settings_getInt (self, BEAT_BOX_SETTINGS_WINDOW_WIDTH, 900);
	result = _tmp0_;
	return result;
}


gint beat_box_settings_getWindowHeight (BeatBoxSettings* self) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = beat_box_settings_getInt (self, BEAT_BOX_SETTINGS_WINDOW_HEIGHT, 600);
	result = _tmp0_;
	return result;
}


gint beat_box_settings_getSidebarWidth (BeatBoxSettings* self) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = beat_box_settings_getInt (self, BEAT_BOX_SETTINGS_SIDEBAR_WIDTH, 200);
	result = _tmp0_;
	return result;
}


gboolean beat_box_settings_getUpdateFolderHierarchy (BeatBoxSettings* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = beat_box_settings_getBool (self, BEAT_BOX_SETTINGS_UPDATE_FOLDER_HIERARCHY, FALSE);
	result = _tmp0_;
	return result;
}


gboolean beat_box_settings_getCopyImportedMusic (BeatBoxSettings* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = beat_box_settings_getBool (self, BEAT_BOX_SETTINGS_COPY_IMPORTED_MUSIC, FALSE);
	result = _tmp0_;
	return result;
}


gchar* beat_box_settings_getLastFMUsername (BeatBoxSettings* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = beat_box_settings_getString (self, BEAT_BOX_SETTINGS_LASTFM_USERNAME, "");
	result = _tmp0_;
	return result;
}


gchar* beat_box_settings_getLastFMPassword (BeatBoxSettings* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = beat_box_settings_getString (self, BEAT_BOX_SETTINGS_LASTFM_PASSWORD, "");
	result = _tmp0_;
	return result;
}


gboolean beat_box_settings_getLastFMAutoLogin (BeatBoxSettings* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = beat_box_settings_getBool (self, BEAT_BOX_SETTINGS_LASTFM_AUTO_LOGIN, FALSE);
	result = _tmp0_;
	return result;
}


gchar* beat_box_settings_getLastFMSessionKey (BeatBoxSettings* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = beat_box_settings_getString (self, BEAT_BOX_SETTINGS_LASTFM_SESSION_KEY, "");
	result = _tmp0_;
	return result;
}


/** Set Values **/
void beat_box_settings_setMusicFolders (BeatBoxSettings* self, const gchar* path) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	beat_box_settings_setString (self, BEAT_BOX_SETTINGS_MUSIC_FOLDERS, path);
}


void beat_box_settings_setMusicFoldersFromList (BeatBoxSettings* self, GeeLinkedList* locations) {
	gchar* _tmp0_;
	gchar* rv;
	g_return_if_fail (self != NULL);
	g_return_if_fail (locations != NULL);
	_tmp0_ = g_strdup ("");
	rv = _tmp0_;
	{
		GeeLinkedList* _tmp1_;
		GeeLinkedList* _location_list;
		gint _tmp2_;
		gint _location_size;
		gint _location_index;
		_tmp1_ = _g_object_ref0 (locations);
		_location_list = _tmp1_;
		_tmp2_ = gee_collection_get_size ((GeeCollection*) _location_list);
		_location_size = _tmp2_;
		_location_index = -1;
		while (TRUE) {
			gpointer _tmp3_ = NULL;
			gchar* location;
			gchar* _tmp4_;
			gchar* _tmp5_;
			_location_index = _location_index + 1;
			if (!(_location_index < _location_size)) {
				break;
			}
			_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _location_list, _location_index);
			location = (gchar*) _tmp3_;
			_tmp4_ = g_strconcat (location, "<location_seperator>", NULL);
			_tmp5_ = g_strconcat (rv, _tmp4_, NULL);
			_g_free0 (rv);
			rv = _tmp5_;
			_g_free0 (_tmp4_);
			_g_free0 (location);
		}
		_g_object_unref0 (_location_list);
	}
	beat_box_settings_setMusicFolders (self, rv);
	_g_free0 (rv);
}


void beat_box_settings_setWindowMaximized (BeatBoxSettings* self, gboolean val) {
	g_return_if_fail (self != NULL);
	beat_box_settings_setBool (self, BEAT_BOX_SETTINGS_WINDOW_MAXIMIZED, val);
}


void beat_box_settings_setWindowWidth (BeatBoxSettings* self, gint val) {
	g_return_if_fail (self != NULL);
	beat_box_settings_setInt (self, BEAT_BOX_SETTINGS_WINDOW_WIDTH, val);
}


void beat_box_settings_setWindowHeight (BeatBoxSettings* self, gint val) {
	g_return_if_fail (self != NULL);
	beat_box_settings_setInt (self, BEAT_BOX_SETTINGS_WINDOW_HEIGHT, val);
}


void beat_box_settings_setSidebarWidth (BeatBoxSettings* self, gint val) {
	g_return_if_fail (self != NULL);
	beat_box_settings_setInt (self, BEAT_BOX_SETTINGS_SIDEBAR_WIDTH, val);
}


void beat_box_settings_setUpdateFolderHierarchy (BeatBoxSettings* self, gboolean val) {
	g_return_if_fail (self != NULL);
	beat_box_settings_setBool (self, BEAT_BOX_SETTINGS_UPDATE_FOLDER_HIERARCHY, val);
}


void beat_box_settings_setCopyImportedMusic (BeatBoxSettings* self, gboolean val) {
	g_return_if_fail (self != NULL);
	beat_box_settings_setBool (self, BEAT_BOX_SETTINGS_COPY_IMPORTED_MUSIC, val);
}


void beat_box_settings_setLastFMUsername (BeatBoxSettings* self, const gchar* val) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (val != NULL);
	beat_box_settings_setString (self, BEAT_BOX_SETTINGS_LASTFM_USERNAME, val);
}


void beat_box_settings_setLastFMPassword (BeatBoxSettings* self, const gchar* val) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (val != NULL);
	beat_box_settings_setString (self, BEAT_BOX_SETTINGS_LASTFM_PASSWORD, val);
}


void beat_box_settings_setLastFMAutoLogin (BeatBoxSettings* self, gboolean val) {
	g_return_if_fail (self != NULL);
	beat_box_settings_setBool (self, BEAT_BOX_SETTINGS_LASTFM_AUTO_LOGIN, val);
}


void beat_box_settings_setLastFMSessionKey (BeatBoxSettings* self, const gchar* val) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (val != NULL);
	beat_box_settings_setString (self, BEAT_BOX_SETTINGS_LASTFM_SESSION_KEY, val);
}


static void beat_box_settings_class_init (BeatBoxSettingsClass * klass) {
	beat_box_settings_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BeatBoxSettingsPrivate));
	G_OBJECT_CLASS (klass)->finalize = beat_box_settings_finalize;
}


static void beat_box_settings_instance_init (BeatBoxSettings * self) {
	self->priv = BEAT_BOX_SETTINGS_GET_PRIVATE (self);
}


static void beat_box_settings_finalize (GObject* obj) {
	BeatBoxSettings * self;
	self = BEAT_BOX_SETTINGS (obj);
	_g_object_unref0 (self->priv->client);
	G_OBJECT_CLASS (beat_box_settings_parent_class)->finalize (obj);
}


GType beat_box_settings_get_type (void) {
	static volatile gsize beat_box_settings_type_id__volatile = 0;
	if (g_once_init_enter (&beat_box_settings_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BeatBoxSettingsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beat_box_settings_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BeatBoxSettings), 0, (GInstanceInitFunc) beat_box_settings_instance_init, NULL };
		GType beat_box_settings_type_id;
		beat_box_settings_type_id = g_type_register_static (G_TYPE_OBJECT, "BeatBoxSettings", &g_define_type_info, 0);
		g_once_init_leave (&beat_box_settings_type_id__volatile, beat_box_settings_type_id);
	}
	return beat_box_settings_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



