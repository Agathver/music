/* NotImportedWindow.c generated by valac 0.11.7, the Vala compiler
 * generated from NotImportedWindow.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>


#define BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW (beat_box_not_imported_window_get_type ())
#define BEAT_BOX_NOT_IMPORTED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW, BeatBoxNotImportedWindow))
#define BEAT_BOX_NOT_IMPORTED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW, BeatBoxNotImportedWindowClass))
#define BEAT_BOX_IS_NOT_IMPORTED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW))
#define BEAT_BOX_IS_NOT_IMPORTED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW))
#define BEAT_BOX_NOT_IMPORTED_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW, BeatBoxNotImportedWindowClass))

typedef struct _BeatBoxNotImportedWindow BeatBoxNotImportedWindow;
typedef struct _BeatBoxNotImportedWindowClass BeatBoxNotImportedWindowClass;
typedef struct _BeatBoxNotImportedWindowPrivate BeatBoxNotImportedWindowPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _BeatBoxNotImportedWindow {
	GtkWindow parent_instance;
	BeatBoxNotImportedWindowPrivate * priv;
};

struct _BeatBoxNotImportedWindowClass {
	GtkWindowClass parent_class;
	void (*trashAllToggled) (BeatBoxNotImportedWindow* self);
	void (*moveToTrashClick) (BeatBoxNotImportedWindow* self);
	void (*ignoreClick) (BeatBoxNotImportedWindow* self);
};

struct _BeatBoxNotImportedWindowPrivate {
	GeeLinkedList* _files;
	GtkVBox* content;
	GtkHBox* padding;
	GtkCheckButton* trashAll;
	GtkScrolledWindow* filesScroll;
	GtkTreeView* filesView;
	GtkListStore* filesModel;
	GtkButton* moveToTrash;
};

struct _Block1Data {
	int _ref_count_;
	BeatBoxNotImportedWindow * self;
	GtkExpander* exp;
};


static gpointer beat_box_not_imported_window_parent_class = NULL;

GType beat_box_not_imported_window_get_type (void) G_GNUC_CONST;
#define BEAT_BOX_NOT_IMPORTED_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW, BeatBoxNotImportedWindowPrivate))
enum  {
	BEAT_BOX_NOT_IMPORTED_WINDOW_DUMMY_PROPERTY
};
BeatBoxNotImportedWindow* beat_box_not_imported_window_new (GeeLinkedList* files);
BeatBoxNotImportedWindow* beat_box_not_imported_window_construct (GType object_type, GeeLinkedList* files);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
static void _lambda17_ (GtkCellRendererToggle* toggle, const gchar* path, BeatBoxNotImportedWindow* self);
gboolean beat_box_not_imported_window_updateMoveToTrashSensetivity (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter);
static gboolean _beat_box_not_imported_window_updateMoveToTrashSensetivity_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self);
static void __lambda17__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self);
GtkAlignment* beat_box_not_imported_window_wrap_alignment (GtkWidget* widget, gint top, gint right, gint bottom, gint left);
void beat_box_not_imported_window_moveToTrashClick (BeatBoxNotImportedWindow* self);
static void _beat_box_not_imported_window_moveToTrashClick_gtk_button_clicked (GtkButton* _sender, gpointer self);
void beat_box_not_imported_window_trashAllToggled (BeatBoxNotImportedWindow* self);
static void _beat_box_not_imported_window_trashAllToggled_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void _lambda18_ (BeatBoxNotImportedWindow* self);
static void __lambda18__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void _lambda19_ (Block1Data* _data1_);
static void __lambda19__gtk_expander_activate (GtkExpander* _sender, gpointer self);
gboolean beat_box_not_imported_window_selectAll (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter);
gboolean beat_box_not_imported_window_unselectAll (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter);
static void beat_box_not_imported_window_real_trashAllToggled (BeatBoxNotImportedWindow* self);
static gboolean _beat_box_not_imported_window_selectAll_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self);
static gboolean _beat_box_not_imported_window_unselectAll_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self);
gboolean beat_box_not_imported_window_deleteSelectedItems (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter);
static void beat_box_not_imported_window_real_moveToTrashClick (BeatBoxNotImportedWindow* self);
static gboolean _beat_box_not_imported_window_deleteSelectedItems_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self);
void beat_box_not_imported_window_ignoreClick (BeatBoxNotImportedWindow* self);
static void beat_box_not_imported_window_real_ignoreClick (BeatBoxNotImportedWindow* self);
static void beat_box_not_imported_window_finalize (GObject* obj);


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->self);
		_g_object_unref0 (_data1_->exp);
		g_slice_free (Block1Data, _data1_);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean _beat_box_not_imported_window_updateMoveToTrashSensetivity_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self) {
	gboolean result;
	result = beat_box_not_imported_window_updateMoveToTrashSensetivity (self, model, path, iter);
	return result;
}


static void _lambda17_ (GtkCellRendererToggle* toggle, const gchar* path, BeatBoxNotImportedWindow* self) {
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* tree_path;
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_;
	g_return_if_fail (toggle != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = gtk_tree_path_new_from_string (path);
	tree_path = _tmp0_;
	gtk_tree_model_get_iter ((GtkTreeModel*) self->priv->filesModel, &_tmp1_, tree_path);
	iter = _tmp1_;
	_tmp2_ = gtk_cell_renderer_toggle_get_active (toggle);
	gtk_list_store_set (self->priv->filesModel, &iter, 0, !_tmp2_, -1);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->moveToTrash, FALSE);
	gtk_tree_model_foreach ((GtkTreeModel*) self->priv->filesModel, _beat_box_not_imported_window_updateMoveToTrashSensetivity_gtk_tree_model_foreach_func, self);
	_gtk_tree_path_free0 (tree_path);
}


static void __lambda17__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self) {
	_lambda17_ (_sender, path, self);
}


static void _beat_box_not_imported_window_moveToTrashClick_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	beat_box_not_imported_window_moveToTrashClick (self);
}


static void _beat_box_not_imported_window_trashAllToggled_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	beat_box_not_imported_window_trashAllToggled (self);
}


static void _lambda18_ (BeatBoxNotImportedWindow* self) {
	gtk_object_destroy ((GtkObject*) self);
}


static void __lambda18__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	_lambda18_ (self);
}


static void _lambda19_ (Block1Data* _data1_) {
	BeatBoxNotImportedWindow * self;
	gboolean _tmp0_;
	self = _data1_->self;
	_tmp0_ = gtk_expander_get_expanded (_data1_->exp);
	if (_tmp0_) {
		g_object_set ((GtkWindow*) self, "allow-shrink", TRUE, NULL);
		gtk_widget_set_size_request ((GtkWidget*) self, 475, 155);
		gtk_window_set_default_size ((GtkWindow*) self, 475, 155);
		g_object_set ((GtkWindow*) self, "allow-shrink", FALSE, NULL);
	} else {
		gtk_widget_set_size_request ((GtkWidget*) self, 475, 350);
	}
}


static void __lambda19__gtk_expander_activate (GtkExpander* _sender, gpointer self) {
	_lambda19_ (self);
}


BeatBoxNotImportedWindow* beat_box_not_imported_window_construct (GType object_type, GeeLinkedList* files) {
	BeatBoxNotImportedWindow * self = NULL;
	Block1Data* _data1_;
	GeeLinkedList* _tmp0_;
	GtkVBox* _tmp1_ = NULL;
	GtkHBox* _tmp2_ = NULL;
	GtkImage* _tmp3_ = NULL;
	GtkImage* warning;
	gint _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	GtkLabel* _tmp11_ = NULL;
	GtkLabel* _tmp12_;
	GtkLabel* title;
	gint _tmp13_;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	gchar* _tmp19_;
	GtkLabel* _tmp20_ = NULL;
	GtkLabel* _tmp21_;
	GtkLabel* info;
	GtkCheckButton* _tmp22_ = NULL;
	GtkScrolledWindow* _tmp23_ = NULL;
	GtkTreeView* _tmp24_ = NULL;
	GtkListStore* _tmp25_ = NULL;
	GtkButton* _tmp26_ = NULL;
	GtkButton* _tmp27_ = NULL;
	GtkButton* okButton;
	gint _tmp28_;
	gchar* _tmp29_ = NULL;
	gchar* _tmp30_;
	gchar* _tmp31_;
	gchar* _tmp32_;
	gchar* _tmp33_;
	gchar* _tmp34_;
	GtkCellRendererToggle* _tmp35_ = NULL;
	GtkCellRendererToggle* toggle;
	GtkTreeViewColumn* _tmp36_ = NULL;
	GtkTreeViewColumn* column;
	GtkCellRendererText* _tmp37_ = NULL;
	GtkCellRendererText* _tmp38_;
	GtkHBox* _tmp43_ = NULL;
	GtkHBox* information;
	GtkVBox* _tmp44_ = NULL;
	GtkVBox* information_text;
	GtkVBox* _tmp45_ = NULL;
	GtkVBox* listBox;
	GtkExpander* _tmp46_ = NULL;
	GtkHButtonBox* _tmp47_ = NULL;
	GtkHButtonBox* bottomButtons;
	GtkAlignment* _tmp48_ = NULL;
	GtkAlignment* _tmp49_;
	GtkAlignment* _tmp50_ = NULL;
	GtkAlignment* _tmp51_;
	g_return_val_if_fail (files != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	self = (BeatBoxNotImportedWindow*) g_object_new (object_type, NULL);
	_data1_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (files);
	_g_object_unref0 (self->priv->_files);
	self->priv->_files = _tmp0_;
	gtk_window_set_title ((GtkWindow*) self, "Not Imported Files");
	gtk_window_set_default_size ((GtkWindow*) self, 475, -1);
	g_object_set ((GtkWindow*) self, "window-position", GTK_WIN_POS_CENTER, NULL);
	g_object_set ((GtkWindow*) self, "allow-shrink", FALSE, NULL);
	_tmp1_ = (GtkVBox*) gtk_vbox_new (FALSE, 10);
	_g_object_unref0 (self->priv->content);
	self->priv->content = g_object_ref_sink (_tmp1_);
	_tmp2_ = (GtkHBox*) gtk_hbox_new (FALSE, 20);
	_g_object_unref0 (self->priv->padding);
	self->priv->padding = g_object_ref_sink (_tmp2_);
	_tmp3_ = (GtkImage*) gtk_image_new_from_stock (GTK_STOCK_DIALOG_ERROR, GTK_ICON_SIZE_DIALOG);
	warning = g_object_ref_sink (_tmp3_);
	_tmp4_ = gee_collection_get_size ((GeeCollection*) files);
	_tmp5_ = g_strdup_printf ("%i", _tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_strconcat ("Unable to import ", _tmp6_, NULL);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strconcat (_tmp8_, "songs", NULL);
	_tmp10_ = _tmp9_;
	_tmp11_ = (GtkLabel*) gtk_label_new (_tmp10_);
	_tmp12_ = g_object_ref_sink (_tmp11_);
	_g_free0 (_tmp10_);
	_g_free0 (_tmp8_);
	_g_free0 (_tmp6_);
	title = _tmp12_;
	_tmp13_ = gee_collection_get_size ((GeeCollection*) files);
	_tmp14_ = g_strdup_printf ("%i", _tmp13_);
	_tmp15_ = _tmp14_;
	_tmp16_ = g_strconcat ("BeatBox was unable to import ", _tmp15_, NULL);
	_tmp17_ = _tmp16_;
	_tmp18_ = g_strconcat (_tmp17_, " songs. The files may be damaged.", NULL);
	_tmp19_ = _tmp18_;
	_tmp20_ = (GtkLabel*) gtk_label_new (_tmp19_);
	_tmp21_ = g_object_ref_sink (_tmp20_);
	_g_free0 (_tmp19_);
	_g_free0 (_tmp17_);
	_g_free0 (_tmp15_);
	info = _tmp21_;
	_tmp22_ = (GtkCheckButton*) gtk_check_button_new_with_label ("Move all corrupted files to trash");
	_g_object_unref0 (self->priv->trashAll);
	self->priv->trashAll = g_object_ref_sink (_tmp22_);
	_tmp23_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	_g_object_unref0 (self->priv->filesScroll);
	self->priv->filesScroll = g_object_ref_sink (_tmp23_);
	_tmp24_ = (GtkTreeView*) gtk_tree_view_new ();
	_g_object_unref0 (self->priv->filesView);
	self->priv->filesView = g_object_ref_sink (_tmp24_);
	_tmp25_ = gtk_list_store_new (2, G_TYPE_BOOLEAN, G_TYPE_STRING);
	_g_object_unref0 (self->priv->filesModel);
	self->priv->filesModel = _tmp25_;
	gtk_tree_view_set_model (self->priv->filesView, (GtkTreeModel*) self->priv->filesModel);
	_tmp26_ = (GtkButton*) gtk_button_new_with_label ("Move to Trash");
	_g_object_unref0 (self->priv->moveToTrash);
	self->priv->moveToTrash = g_object_ref_sink (_tmp26_);
	_tmp27_ = (GtkButton*) gtk_button_new_with_label ("Ignore");
	okButton = g_object_ref_sink (_tmp27_);
	g_object_set ((GtkMisc*) title, "xalign", 0.0f, NULL);
	_tmp28_ = gee_collection_get_size ((GeeCollection*) files);
	_tmp29_ = g_strdup_printf ("%i", _tmp28_);
	_tmp30_ = _tmp29_;
	_tmp31_ = g_strconcat ("<span weight=\"bold\" size=\"larger\">Unable to import ", _tmp30_, NULL);
	_tmp32_ = _tmp31_;
	_tmp33_ = g_strconcat (_tmp32_, " songs</span>", NULL);
	_tmp34_ = _tmp33_;
	gtk_label_set_markup (title, _tmp34_);
	_g_free0 (_tmp34_);
	_g_free0 (_tmp32_);
	_g_free0 (_tmp30_);
	g_object_set ((GtkMisc*) info, "xalign", 0.0f, NULL);
	gtk_label_set_line_wrap (info, FALSE);
	_tmp35_ = (GtkCellRendererToggle*) gtk_cell_renderer_toggle_new ();
	toggle = g_object_ref_sink (_tmp35_);
	g_signal_connect_object (toggle, "toggled", (GCallback) __lambda17__gtk_cell_renderer_toggle_toggled, self, 0);
	_tmp36_ = gtk_tree_view_column_new ();
	column = g_object_ref_sink (_tmp36_);
	gtk_tree_view_column_set_title (column, "del");
	gtk_cell_layout_pack_start ((GtkCellLayout*) column, (GtkCellRenderer*) toggle, FALSE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) column, (GtkCellRenderer*) toggle, "active", 0);
	gtk_tree_view_append_column (self->priv->filesView, column);
	_tmp37_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp38_ = g_object_ref_sink (_tmp37_);
	gtk_tree_view_insert_column_with_attributes (self->priv->filesView, -1, "File Location", (GtkCellRenderer*) _tmp38_, "text", 1, NULL, NULL);
	_g_object_unref0 (_tmp38_);
	gtk_tree_view_set_headers_visible (self->priv->filesView, FALSE);
	{
		GeeLinkedList* _tmp39_;
		GeeLinkedList* _file_list;
		gint _tmp40_;
		gint _file_size;
		gint _file_index;
		_tmp39_ = _g_object_ref0 (files);
		_file_list = _tmp39_;
		_tmp40_ = gee_collection_get_size ((GeeCollection*) _file_list);
		_file_size = _tmp40_;
		_file_index = -1;
		while (TRUE) {
			gpointer _tmp41_ = NULL;
			gchar* file;
			GtkTreeIter item = {0};
			GtkTreeIter _tmp42_ = {0};
			_file_index = _file_index + 1;
			if (!(_file_index < _file_size)) {
				break;
			}
			_tmp41_ = gee_abstract_list_get ((GeeAbstractList*) _file_list, _file_index);
			file = (gchar*) _tmp41_;
			gtk_list_store_append (self->priv->filesModel, &_tmp42_);
			item = _tmp42_;
			gtk_list_store_set (self->priv->filesModel, &item, 0, FALSE, 1, file, -1);
			_g_free0 (file);
		}
		_g_object_unref0 (_file_list);
	}
	gtk_container_add ((GtkContainer*) self->priv->filesScroll, (GtkWidget*) self->priv->filesView);
	gtk_scrolled_window_set_policy (self->priv->filesScroll, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_widget_set_sensitive ((GtkWidget*) self->priv->moveToTrash, FALSE);
	_tmp43_ = (GtkHBox*) gtk_hbox_new (FALSE, 0);
	information = g_object_ref_sink (_tmp43_);
	_tmp44_ = (GtkVBox*) gtk_vbox_new (FALSE, 0);
	information_text = g_object_ref_sink (_tmp44_);
	gtk_box_pack_start ((GtkBox*) information, (GtkWidget*) warning, FALSE, FALSE, (guint) 10);
	gtk_box_pack_start ((GtkBox*) information_text, (GtkWidget*) title, FALSE, TRUE, (guint) 10);
	gtk_box_pack_start ((GtkBox*) information_text, (GtkWidget*) info, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) information, (GtkWidget*) information_text, TRUE, TRUE, (guint) 10);
	_tmp45_ = (GtkVBox*) gtk_vbox_new (FALSE, 0);
	listBox = g_object_ref_sink (_tmp45_);
	gtk_box_pack_start ((GtkBox*) listBox, (GtkWidget*) self->priv->filesScroll, TRUE, TRUE, (guint) 5);
	_tmp46_ = (GtkExpander*) gtk_expander_new ("Select individual files to move to trash:");
	_data1_->exp = g_object_ref_sink (_tmp46_);
	gtk_container_add ((GtkContainer*) _data1_->exp, (GtkWidget*) listBox);
	gtk_expander_set_expanded (_data1_->exp, FALSE);
	_tmp47_ = (GtkHButtonBox*) gtk_hbutton_box_new ();
	bottomButtons = g_object_ref_sink (_tmp47_);
	gtk_button_box_set_layout ((GtkButtonBox*) bottomButtons, GTK_BUTTONBOX_END);
	gtk_box_pack_end ((GtkBox*) bottomButtons, (GtkWidget*) self->priv->moveToTrash, FALSE, FALSE, (guint) 0);
	gtk_box_pack_end ((GtkBox*) bottomButtons, (GtkWidget*) okButton, FALSE, FALSE, (guint) 10);
	gtk_box_set_spacing ((GtkBox*) bottomButtons, 10);
	((GtkButtonBox*) bottomButtons)->child_ipad_x = 10;
	gtk_box_pack_start ((GtkBox*) self->priv->content, (GtkWidget*) information, FALSE, TRUE, (guint) 0);
	_tmp48_ = beat_box_not_imported_window_wrap_alignment ((GtkWidget*) self->priv->trashAll, 5, 0, 0, 75);
	_tmp49_ = _tmp48_;
	gtk_box_pack_start ((GtkBox*) self->priv->content, (GtkWidget*) _tmp49_, FALSE, TRUE, (guint) 0);
	_g_object_unref0 (_tmp49_);
	_tmp50_ = beat_box_not_imported_window_wrap_alignment ((GtkWidget*) _data1_->exp, 0, 0, 0, 75);
	_tmp51_ = _tmp50_;
	gtk_box_pack_start ((GtkBox*) self->priv->content, (GtkWidget*) _tmp51_, TRUE, TRUE, (guint) 0);
	_g_object_unref0 (_tmp51_);
	gtk_box_pack_start ((GtkBox*) self->priv->content, (GtkWidget*) bottomButtons, FALSE, TRUE, (guint) 10);
	gtk_box_pack_start ((GtkBox*) self->priv->padding, (GtkWidget*) self->priv->content, TRUE, TRUE, (guint) 10);
	g_signal_connect_object (self->priv->moveToTrash, "clicked", (GCallback) _beat_box_not_imported_window_moveToTrashClick_gtk_button_clicked, self, 0);
	g_signal_connect_object ((GtkToggleButton*) self->priv->trashAll, "toggled", (GCallback) _beat_box_not_imported_window_trashAllToggled_gtk_toggle_button_toggled, self, 0);
	g_signal_connect_object (okButton, "clicked", (GCallback) __lambda18__gtk_button_clicked, self, 0);
	g_signal_connect_data (_data1_->exp, "activate", (GCallback) __lambda19__gtk_expander_activate, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->padding);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (bottomButtons);
	_g_object_unref0 (listBox);
	_g_object_unref0 (information_text);
	_g_object_unref0 (information);
	_g_object_unref0 (column);
	_g_object_unref0 (toggle);
	_g_object_unref0 (okButton);
	_g_object_unref0 (info);
	_g_object_unref0 (title);
	_g_object_unref0 (warning);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return self;
}


BeatBoxNotImportedWindow* beat_box_not_imported_window_new (GeeLinkedList* files) {
	return beat_box_not_imported_window_construct (BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW, files);
}


GtkAlignment* beat_box_not_imported_window_wrap_alignment (GtkWidget* widget, gint top, gint right, gint bottom, gint left) {
	GtkAlignment* result = NULL;
	GtkAlignment* _tmp0_ = NULL;
	GtkAlignment* alignment;
	g_return_val_if_fail (widget != NULL, NULL);
	_tmp0_ = (GtkAlignment*) gtk_alignment_new (0.0f, 0.0f, 1.0f, 1.0f);
	alignment = g_object_ref_sink (_tmp0_);
	g_object_set (alignment, "top-padding", (guint) top, NULL);
	g_object_set (alignment, "right-padding", (guint) right, NULL);
	g_object_set (alignment, "bottom-padding", (guint) bottom, NULL);
	g_object_set (alignment, "left-padding", (guint) left, NULL);
	gtk_container_add ((GtkContainer*) alignment, widget);
	result = alignment;
	return result;
}


gboolean beat_box_not_imported_window_updateMoveToTrashSensetivity (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter) {
	gboolean result = FALSE;
	gboolean sel;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (model != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	sel = FALSE;
	gtk_tree_model_get (model, iter, 0, &sel, -1);
	if (sel) {
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->moveToTrash, TRUE);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


gboolean beat_box_not_imported_window_selectAll (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (model != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	gtk_list_store_set (self->priv->filesModel, iter, 0, TRUE, -1);
	result = FALSE;
	return result;
}


gboolean beat_box_not_imported_window_unselectAll (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (model != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	gtk_list_store_set (self->priv->filesModel, iter, 0, FALSE, -1);
	result = FALSE;
	return result;
}


static gboolean _beat_box_not_imported_window_selectAll_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self) {
	gboolean result;
	result = beat_box_not_imported_window_selectAll (self, model, path, iter);
	return result;
}


static gboolean _beat_box_not_imported_window_unselectAll_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self) {
	gboolean result;
	result = beat_box_not_imported_window_unselectAll (self, model, path, iter);
	return result;
}


static void beat_box_not_imported_window_real_trashAllToggled (BeatBoxNotImportedWindow* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->trashAll);
	if (_tmp0_) {
		gtk_tree_model_foreach ((GtkTreeModel*) self->priv->filesModel, _beat_box_not_imported_window_selectAll_gtk_tree_model_foreach_func, self);
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->filesView, FALSE);
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->moveToTrash, TRUE);
	} else {
		gtk_tree_model_foreach ((GtkTreeModel*) self->priv->filesModel, _beat_box_not_imported_window_unselectAll_gtk_tree_model_foreach_func, self);
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->filesView, TRUE);
		gtk_widget_set_sensitive ((GtkWidget*) self->priv->moveToTrash, FALSE);
	}
}


void beat_box_not_imported_window_trashAllToggled (BeatBoxNotImportedWindow* self) {
	BEAT_BOX_NOT_IMPORTED_WINDOW_GET_CLASS (self)->trashAllToggled (self);
}


gboolean beat_box_not_imported_window_deleteSelectedItems (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter) {
	gboolean result = FALSE;
	gboolean selected = FALSE;
	gchar* location = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (model != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	gtk_tree_model_get ((GtkTreeModel*) self->priv->filesModel, iter, 0, &selected, -1);
	gtk_tree_model_get ((GtkTreeModel*) self->priv->filesModel, iter, 1, &location, -1);
	if (selected) {
		GFile* _tmp0_ = NULL;
		GFile* file;
		_tmp0_ = g_file_new_for_path (location);
		file = _tmp0_;
		g_file_trash (file, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (file);
			goto __catch28_g_error;
		}
		_g_object_unref0 (file);
		goto __finally28;
		__catch28_g_error:
		{
			GError * err;
			err = _inner_error_;
			_inner_error_ = NULL;
			fprintf (stdout, "Could not move file %s to recycle: %s\n", location, err->message);
			_g_error_free0 (err);
		}
		__finally28:
		if (_inner_error_ != NULL) {
			_g_free0 (location);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	result = FALSE;
	_g_free0 (location);
	return result;
}


static gboolean _beat_box_not_imported_window_deleteSelectedItems_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self) {
	gboolean result;
	result = beat_box_not_imported_window_deleteSelectedItems (self, model, path, iter);
	return result;
}


static void beat_box_not_imported_window_real_moveToTrashClick (BeatBoxNotImportedWindow* self) {
	g_return_if_fail (self != NULL);
	gtk_tree_model_foreach ((GtkTreeModel*) self->priv->filesModel, _beat_box_not_imported_window_deleteSelectedItems_gtk_tree_model_foreach_func, self);
	gtk_object_destroy ((GtkObject*) self);
}


void beat_box_not_imported_window_moveToTrashClick (BeatBoxNotImportedWindow* self) {
	BEAT_BOX_NOT_IMPORTED_WINDOW_GET_CLASS (self)->moveToTrashClick (self);
}


static void beat_box_not_imported_window_real_ignoreClick (BeatBoxNotImportedWindow* self) {
	g_return_if_fail (self != NULL);
	gtk_object_destroy ((GtkObject*) self);
}


void beat_box_not_imported_window_ignoreClick (BeatBoxNotImportedWindow* self) {
	BEAT_BOX_NOT_IMPORTED_WINDOW_GET_CLASS (self)->ignoreClick (self);
}


static void beat_box_not_imported_window_class_init (BeatBoxNotImportedWindowClass * klass) {
	beat_box_not_imported_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BeatBoxNotImportedWindowPrivate));
	BEAT_BOX_NOT_IMPORTED_WINDOW_CLASS (klass)->trashAllToggled = beat_box_not_imported_window_real_trashAllToggled;
	BEAT_BOX_NOT_IMPORTED_WINDOW_CLASS (klass)->moveToTrashClick = beat_box_not_imported_window_real_moveToTrashClick;
	BEAT_BOX_NOT_IMPORTED_WINDOW_CLASS (klass)->ignoreClick = beat_box_not_imported_window_real_ignoreClick;
	G_OBJECT_CLASS (klass)->finalize = beat_box_not_imported_window_finalize;
}


static void beat_box_not_imported_window_instance_init (BeatBoxNotImportedWindow * self) {
	self->priv = BEAT_BOX_NOT_IMPORTED_WINDOW_GET_PRIVATE (self);
}


static void beat_box_not_imported_window_finalize (GObject* obj) {
	BeatBoxNotImportedWindow * self;
	self = BEAT_BOX_NOT_IMPORTED_WINDOW (obj);
	_g_object_unref0 (self->priv->_files);
	_g_object_unref0 (self->priv->content);
	_g_object_unref0 (self->priv->padding);
	_g_object_unref0 (self->priv->trashAll);
	_g_object_unref0 (self->priv->filesScroll);
	_g_object_unref0 (self->priv->filesView);
	_g_object_unref0 (self->priv->filesModel);
	_g_object_unref0 (self->priv->moveToTrash);
	G_OBJECT_CLASS (beat_box_not_imported_window_parent_class)->finalize (obj);
}


GType beat_box_not_imported_window_get_type (void) {
	static volatile gsize beat_box_not_imported_window_type_id__volatile = 0;
	if (g_once_init_enter (&beat_box_not_imported_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BeatBoxNotImportedWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beat_box_not_imported_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BeatBoxNotImportedWindow), 0, (GInstanceInitFunc) beat_box_not_imported_window_instance_init, NULL };
		GType beat_box_not_imported_window_type_id;
		beat_box_not_imported_window_type_id = g_type_register_static (GTK_TYPE_WINDOW, "BeatBoxNotImportedWindow", &g_define_type_info, 0);
		g_once_init_leave (&beat_box_not_imported_window_type_id__volatile, beat_box_not_imported_window_type_id);
	}
	return beat_box_not_imported_window_type_id__volatile;
}



