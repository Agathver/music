/* NotImportedWindow.c generated by valac 0.11.5, the Vala compiler
 * generated from NotImportedWindow.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>


#define BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW (beat_box_not_imported_window_get_type ())
#define BEAT_BOX_NOT_IMPORTED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW, BeatBoxNotImportedWindow))
#define BEAT_BOX_NOT_IMPORTED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW, BeatBoxNotImportedWindowClass))
#define BEAT_BOX_IS_NOT_IMPORTED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW))
#define BEAT_BOX_IS_NOT_IMPORTED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW))
#define BEAT_BOX_NOT_IMPORTED_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW, BeatBoxNotImportedWindowClass))

typedef struct _BeatBoxNotImportedWindow BeatBoxNotImportedWindow;
typedef struct _BeatBoxNotImportedWindowClass BeatBoxNotImportedWindowClass;
typedef struct _BeatBoxNotImportedWindowPrivate BeatBoxNotImportedWindowPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _BeatBoxNotImportedWindow {
	GtkWindow parent_instance;
	BeatBoxNotImportedWindowPrivate * priv;
};

struct _BeatBoxNotImportedWindowClass {
	GtkWindowClass parent_class;
	void (*moveToRecycleToggle) (BeatBoxNotImportedWindow* self);
	void (*deleteAllClick) (BeatBoxNotImportedWindow* self);
	void (*deleteSelectedClick) (BeatBoxNotImportedWindow* self);
	void (*ignoreClick) (BeatBoxNotImportedWindow* self);
};

struct _BeatBoxNotImportedWindowPrivate {
	GeeLinkedList* _files;
	GtkScrolledWindow* filesScroll;
	GtkTreeView* filesView;
	GtkListStore* filesModel;
	GtkCheckButton* moveToRecycle;
	GtkButton* deleteAll;
	GtkButton* deleteSelected;
	GtkButton* ignore;
};


static gpointer beat_box_not_imported_window_parent_class = NULL;

GType beat_box_not_imported_window_get_type (void) G_GNUC_CONST;
#define BEAT_BOX_NOT_IMPORTED_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW, BeatBoxNotImportedWindowPrivate))
enum  {
	BEAT_BOX_NOT_IMPORTED_WINDOW_DUMMY_PROPERTY
};
BeatBoxNotImportedWindow* beat_box_not_imported_window_new (GeeLinkedList* files);
BeatBoxNotImportedWindow* beat_box_not_imported_window_construct (GType object_type, GeeLinkedList* files);
static void _lambda13_ (GtkCellRendererToggle* toggle, const gchar* path, BeatBoxNotImportedWindow* self);
static void __lambda13__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self);
void beat_box_not_imported_window_moveToRecycleToggle (BeatBoxNotImportedWindow* self);
static void _beat_box_not_imported_window_moveToRecycleToggle_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
void beat_box_not_imported_window_deleteAllClick (BeatBoxNotImportedWindow* self);
static void _beat_box_not_imported_window_deleteAllClick_gtk_button_clicked (GtkButton* _sender, gpointer self);
void beat_box_not_imported_window_deleteSelectedClick (BeatBoxNotImportedWindow* self);
static void _beat_box_not_imported_window_deleteSelectedClick_gtk_button_clicked (GtkButton* _sender, gpointer self);
void beat_box_not_imported_window_ignoreClick (BeatBoxNotImportedWindow* self);
static void _beat_box_not_imported_window_ignoreClick_gtk_button_clicked (GtkButton* _sender, gpointer self);
gboolean beat_box_not_imported_window_selectAll (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter);
gboolean beat_box_not_imported_window_deleteSelectedItems (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter);
static void beat_box_not_imported_window_real_moveToRecycleToggle (BeatBoxNotImportedWindow* self);
static void beat_box_not_imported_window_real_deleteAllClick (BeatBoxNotImportedWindow* self);
static gboolean _beat_box_not_imported_window_selectAll_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self);
static void beat_box_not_imported_window_real_deleteSelectedClick (BeatBoxNotImportedWindow* self);
static gboolean _beat_box_not_imported_window_deleteSelectedItems_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self);
static void beat_box_not_imported_window_real_ignoreClick (BeatBoxNotImportedWindow* self);
static void beat_box_not_imported_window_finalize (GObject* obj);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _lambda13_ (GtkCellRendererToggle* toggle, const gchar* path, BeatBoxNotImportedWindow* self) {
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* tree_path;
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_;
	g_return_if_fail (toggle != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = gtk_tree_path_new_from_string (path);
	tree_path = _tmp0_;
	gtk_tree_model_get_iter ((GtkTreeModel*) self->priv->filesModel, &_tmp1_, tree_path);
	iter = _tmp1_;
	_tmp2_ = gtk_cell_renderer_toggle_get_active (toggle);
	gtk_list_store_set (self->priv->filesModel, &iter, 0, !_tmp2_, -1);
	_gtk_tree_path_free0 (tree_path);
}


static void __lambda13__gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self) {
	_lambda13_ (_sender, path, self);
}


static void _beat_box_not_imported_window_moveToRecycleToggle_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	beat_box_not_imported_window_moveToRecycleToggle (self);
}


static void _beat_box_not_imported_window_deleteAllClick_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	beat_box_not_imported_window_deleteAllClick (self);
}


static void _beat_box_not_imported_window_deleteSelectedClick_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	beat_box_not_imported_window_deleteSelectedClick (self);
}


static void _beat_box_not_imported_window_ignoreClick_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	beat_box_not_imported_window_ignoreClick (self);
}


BeatBoxNotImportedWindow* beat_box_not_imported_window_construct (GType object_type, GeeLinkedList* files) {
	BeatBoxNotImportedWindow * self = NULL;
	GeeLinkedList* _tmp0_;
	GeeLinkedList* _tmp1_;
	GtkLabel* _tmp2_ = NULL;
	GtkLabel* info;
	GtkScrolledWindow* _tmp3_ = NULL;
	GtkScrolledWindow* _tmp4_;
	GtkTreeView* _tmp5_ = NULL;
	GtkTreeView* _tmp6_;
	GtkListStore* _tmp7_ = NULL;
	GtkListStore* _tmp8_;
	GtkCheckButton* _tmp9_ = NULL;
	GtkCheckButton* _tmp10_;
	GtkButton* _tmp11_ = NULL;
	GtkButton* _tmp12_;
	GtkButton* _tmp13_ = NULL;
	GtkButton* _tmp14_;
	GtkButton* _tmp15_ = NULL;
	GtkButton* _tmp16_;
	GtkCellRendererToggle* _tmp17_ = NULL;
	GtkCellRendererToggle* toggle;
	GtkTreeViewColumn* _tmp18_ = NULL;
	GtkTreeViewColumn* column;
	GtkCellRendererText* _tmp19_ = NULL;
	GtkCellRendererText* _tmp20_;
	GtkHButtonBox* _tmp25_ = NULL;
	GtkHButtonBox* buttons;
	GtkLabel* _tmp26_ = NULL;
	GtkLabel* filler;
	GtkVBox* _tmp27_ = NULL;
	GtkVBox* vbox;
	g_return_val_if_fail (files != NULL, NULL);
	self = (BeatBoxNotImportedWindow*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (files);
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->_files);
	self->priv->_files = _tmp1_;
	gtk_window_set_title ((GtkWindow*) self, "Not Imported Files");
	gtk_widget_set_size_request ((GtkWidget*) self, 600, 400);
	g_object_set ((GtkWindow*) self, "allow-shrink", TRUE, NULL);
	_tmp2_ = (GtkLabel*) gtk_label_new ("The following files could not be imported because they are corrupt.");
	info = g_object_ref_sink (_tmp2_);
	_tmp3_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	_tmp4_ = g_object_ref_sink (_tmp3_);
	_g_object_unref0 (self->priv->filesScroll);
	self->priv->filesScroll = _tmp4_;
	_tmp5_ = (GtkTreeView*) gtk_tree_view_new ();
	_tmp6_ = g_object_ref_sink (_tmp5_);
	_g_object_unref0 (self->priv->filesView);
	self->priv->filesView = _tmp6_;
	_tmp7_ = gtk_list_store_new (2, G_TYPE_BOOLEAN, G_TYPE_STRING);
	_tmp8_ = _tmp7_;
	_g_object_unref0 (self->priv->filesModel);
	self->priv->filesModel = _tmp8_;
	gtk_tree_view_set_model (self->priv->filesView, (GtkTreeModel*) self->priv->filesModel);
	_tmp9_ = (GtkCheckButton*) gtk_check_button_new_with_label ("Recycle");
	_tmp10_ = g_object_ref_sink (_tmp9_);
	_g_object_unref0 (self->priv->moveToRecycle);
	self->priv->moveToRecycle = _tmp10_;
	_tmp11_ = (GtkButton*) gtk_button_new_with_label ("Delete all");
	_tmp12_ = g_object_ref_sink (_tmp11_);
	_g_object_unref0 (self->priv->deleteAll);
	self->priv->deleteAll = _tmp12_;
	_tmp13_ = (GtkButton*) gtk_button_new_with_label ("Delete checked");
	_tmp14_ = g_object_ref_sink (_tmp13_);
	_g_object_unref0 (self->priv->deleteSelected);
	self->priv->deleteSelected = _tmp14_;
	_tmp15_ = (GtkButton*) gtk_button_new_with_label ("Ignore files");
	_tmp16_ = g_object_ref_sink (_tmp15_);
	_g_object_unref0 (self->priv->ignore);
	self->priv->ignore = _tmp16_;
	gtk_label_set_line_wrap (info, FALSE);
	_tmp17_ = (GtkCellRendererToggle*) gtk_cell_renderer_toggle_new ();
	toggle = g_object_ref_sink (_tmp17_);
	g_signal_connect_object (toggle, "toggled", (GCallback) __lambda13__gtk_cell_renderer_toggle_toggled, self, 0);
	_tmp18_ = gtk_tree_view_column_new ();
	column = g_object_ref_sink (_tmp18_);
	gtk_tree_view_column_set_title (column, "Delete");
	gtk_cell_layout_pack_start ((GtkCellLayout*) column, (GtkCellRenderer*) toggle, FALSE);
	gtk_cell_layout_add_attribute ((GtkCellLayout*) column, (GtkCellRenderer*) toggle, "active", 0);
	gtk_tree_view_append_column (self->priv->filesView, column);
	_tmp19_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	_tmp20_ = g_object_ref_sink (_tmp19_);
	gtk_tree_view_insert_column_with_attributes (self->priv->filesView, -1, "File Location", (GtkCellRenderer*) _tmp20_, "text", 1, NULL, NULL);
	_g_object_unref0 (_tmp20_);
	{
		GeeLinkedList* _tmp21_;
		GeeLinkedList* _file_list;
		gint _tmp22_;
		gint _file_size;
		gint _file_index;
		_tmp21_ = _g_object_ref0 (files);
		_file_list = _tmp21_;
		_tmp22_ = gee_collection_get_size ((GeeCollection*) _file_list);
		_file_size = _tmp22_;
		_file_index = -1;
		while (TRUE) {
			gpointer _tmp23_ = NULL;
			gchar* file;
			GtkTreeIter item = {0};
			GtkTreeIter _tmp24_ = {0};
			_file_index = _file_index + 1;
			if (!(_file_index < _file_size)) {
				break;
			}
			_tmp23_ = gee_abstract_list_get ((GeeAbstractList*) _file_list, _file_index);
			file = (gchar*) _tmp23_;
			gtk_list_store_append (self->priv->filesModel, &_tmp24_);
			item = _tmp24_;
			gtk_list_store_set (self->priv->filesModel, &item, 0, FALSE, 1, file, -1);
			_g_free0 (file);
		}
		_g_object_unref0 (_file_list);
	}
	_tmp25_ = (GtkHButtonBox*) gtk_hbutton_box_new ();
	buttons = g_object_ref_sink (_tmp25_);
	_tmp26_ = (GtkLabel*) gtk_label_new ("");
	filler = g_object_ref_sink (_tmp26_);
	gtk_container_add ((GtkContainer*) self->priv->filesScroll, (GtkWidget*) self->priv->filesView);
	gtk_scrolled_window_set_policy (self->priv->filesScroll, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_box_pack_start ((GtkBox*) buttons, (GtkWidget*) self->priv->moveToRecycle, FALSE, FALSE, (guint) 5);
	gtk_box_pack_start ((GtkBox*) buttons, (GtkWidget*) self->priv->deleteAll, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) buttons, (GtkWidget*) self->priv->deleteSelected, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) buttons, (GtkWidget*) filler, FALSE, TRUE, (guint) 0);
	gtk_box_pack_end ((GtkBox*) buttons, (GtkWidget*) self->priv->ignore, FALSE, FALSE, (guint) 5);
	_tmp27_ = (GtkVBox*) gtk_vbox_new (FALSE, 0);
	vbox = g_object_ref_sink (_tmp27_);
	gtk_box_pack_start ((GtkBox*) vbox, (GtkWidget*) info, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) vbox, (GtkWidget*) self->priv->filesScroll, TRUE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) vbox, (GtkWidget*) buttons, FALSE, TRUE, (guint) 5);
	g_signal_connect_object ((GtkToggleButton*) self->priv->moveToRecycle, "toggled", (GCallback) _beat_box_not_imported_window_moveToRecycleToggle_gtk_toggle_button_toggled, self, 0);
	g_signal_connect_object (self->priv->deleteAll, "clicked", (GCallback) _beat_box_not_imported_window_deleteAllClick_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->priv->deleteSelected, "clicked", (GCallback) _beat_box_not_imported_window_deleteSelectedClick_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->priv->ignore, "clicked", (GCallback) _beat_box_not_imported_window_ignoreClick_gtk_button_clicked, self, 0);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) vbox);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (vbox);
	_g_object_unref0 (filler);
	_g_object_unref0 (buttons);
	_g_object_unref0 (column);
	_g_object_unref0 (toggle);
	_g_object_unref0 (info);
	return self;
}


BeatBoxNotImportedWindow* beat_box_not_imported_window_new (GeeLinkedList* files) {
	return beat_box_not_imported_window_construct (BEAT_BOX_TYPE_NOT_IMPORTED_WINDOW, files);
}


gboolean beat_box_not_imported_window_selectAll (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (model != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	gtk_list_store_set (self->priv->filesModel, iter, 0, TRUE, -1);
	result = FALSE;
	return result;
}


gboolean beat_box_not_imported_window_deleteSelectedItems (BeatBoxNotImportedWindow* self, GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter) {
	gboolean result = FALSE;
	gboolean selected = FALSE;
	gchar* location = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (model != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	gtk_tree_model_get ((GtkTreeModel*) self->priv->filesModel, iter, 0, &selected, -1);
	gtk_tree_model_get ((GtkTreeModel*) self->priv->filesModel, iter, 1, &location, -1);
	if (selected) {
		gboolean _tmp0_;
		_tmp0_ = gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->moveToRecycle);
		if (_tmp0_) {
			GFile* _tmp1_ = NULL;
			GFile* file;
			_tmp1_ = g_file_new_for_path (location);
			file = _tmp1_;
			g_file_trash (file, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (file);
				goto __catch38_g_error;
			}
			_g_object_unref0 (file);
			goto __finally38;
			__catch38_g_error:
			{
				GError * err;
				err = _inner_error_;
				_inner_error_ = NULL;
				fprintf (stdout, "Could not move file %s to recycle: %s\n", location, err->message);
				_g_error_free0 (err);
			}
			__finally38:
			if (_inner_error_ != NULL) {
				_g_free0 (location);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		} else {
			GFile* _tmp2_ = NULL;
			GFile* file;
			_tmp2_ = g_file_new_for_path (location);
			file = _tmp2_;
			g_file_delete (file, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (file);
				goto __catch39_g_error;
			}
			_g_object_unref0 (file);
			goto __finally39;
			__catch39_g_error:
			{
				GError * err;
				err = _inner_error_;
				_inner_error_ = NULL;
				fprintf (stdout, "Could not delete file %s: %s\n", location, err->message);
				_g_error_free0 (err);
			}
			__finally39:
			if (_inner_error_ != NULL) {
				_g_free0 (location);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
	}
	result = FALSE;
	_g_free0 (location);
	return result;
}


static void beat_box_not_imported_window_real_moveToRecycleToggle (BeatBoxNotImportedWindow* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->moveToRecycle);
	if (_tmp0_) {
		gtk_button_set_label (self->priv->deleteAll, "Recycle all");
		gtk_button_set_label (self->priv->deleteSelected, "Recycle selected");
	} else {
		gtk_button_set_label (self->priv->deleteAll, "Delete all");
		gtk_button_set_label (self->priv->deleteSelected, "Delete selected");
	}
}


void beat_box_not_imported_window_moveToRecycleToggle (BeatBoxNotImportedWindow* self) {
	BEAT_BOX_NOT_IMPORTED_WINDOW_GET_CLASS (self)->moveToRecycleToggle (self);
}


static gboolean _beat_box_not_imported_window_selectAll_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self) {
	gboolean result;
	result = beat_box_not_imported_window_selectAll (self, model, path, iter);
	return result;
}


static void beat_box_not_imported_window_real_deleteAllClick (BeatBoxNotImportedWindow* self) {
	g_return_if_fail (self != NULL);
	gtk_tree_model_foreach ((GtkTreeModel*) self->priv->filesModel, _beat_box_not_imported_window_selectAll_gtk_tree_model_foreach_func, self);
	beat_box_not_imported_window_deleteSelectedClick (self);
}


void beat_box_not_imported_window_deleteAllClick (BeatBoxNotImportedWindow* self) {
	BEAT_BOX_NOT_IMPORTED_WINDOW_GET_CLASS (self)->deleteAllClick (self);
}


static gboolean _beat_box_not_imported_window_deleteSelectedItems_gtk_tree_model_foreach_func (GtkTreeModel* model, GtkTreePath* path, GtkTreeIter* iter, gpointer self) {
	gboolean result;
	result = beat_box_not_imported_window_deleteSelectedItems (self, model, path, iter);
	return result;
}


static void beat_box_not_imported_window_real_deleteSelectedClick (BeatBoxNotImportedWindow* self) {
	g_return_if_fail (self != NULL);
	gtk_tree_model_foreach ((GtkTreeModel*) self->priv->filesModel, _beat_box_not_imported_window_deleteSelectedItems_gtk_tree_model_foreach_func, self);
	gtk_object_destroy ((GtkObject*) self);
}


void beat_box_not_imported_window_deleteSelectedClick (BeatBoxNotImportedWindow* self) {
	BEAT_BOX_NOT_IMPORTED_WINDOW_GET_CLASS (self)->deleteSelectedClick (self);
}


static void beat_box_not_imported_window_real_ignoreClick (BeatBoxNotImportedWindow* self) {
	g_return_if_fail (self != NULL);
	gtk_object_destroy ((GtkObject*) self);
}


void beat_box_not_imported_window_ignoreClick (BeatBoxNotImportedWindow* self) {
	BEAT_BOX_NOT_IMPORTED_WINDOW_GET_CLASS (self)->ignoreClick (self);
}


static void beat_box_not_imported_window_class_init (BeatBoxNotImportedWindowClass * klass) {
	beat_box_not_imported_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BeatBoxNotImportedWindowPrivate));
	BEAT_BOX_NOT_IMPORTED_WINDOW_CLASS (klass)->moveToRecycleToggle = beat_box_not_imported_window_real_moveToRecycleToggle;
	BEAT_BOX_NOT_IMPORTED_WINDOW_CLASS (klass)->deleteAllClick = beat_box_not_imported_window_real_deleteAllClick;
	BEAT_BOX_NOT_IMPORTED_WINDOW_CLASS (klass)->deleteSelectedClick = beat_box_not_imported_window_real_deleteSelectedClick;
	BEAT_BOX_NOT_IMPORTED_WINDOW_CLASS (klass)->ignoreClick = beat_box_not_imported_window_real_ignoreClick;
	G_OBJECT_CLASS (klass)->finalize = beat_box_not_imported_window_finalize;
}


static void beat_box_not_imported_window_instance_init (BeatBoxNotImportedWindow * self) {
	self->priv = BEAT_BOX_NOT_IMPORTED_WINDOW_GET_PRIVATE (self);
}


static void beat_box_not_imported_window_finalize (GObject* obj) {
	BeatBoxNotImportedWindow * self;
	self = BEAT_BOX_NOT_IMPORTED_WINDOW (obj);
	_g_object_unref0 (self->priv->_files);
	_g_object_unref0 (self->priv->filesScroll);
	_g_object_unref0 (self->priv->filesView);
	_g_object_unref0 (self->priv->filesModel);
	_g_object_unref0 (self->priv->moveToRecycle);
	_g_object_unref0 (self->priv->deleteAll);
	_g_object_unref0 (self->priv->deleteSelected);
	_g_object_unref0 (self->priv->ignore);
	G_OBJECT_CLASS (beat_box_not_imported_window_parent_class)->finalize (obj);
}


GType beat_box_not_imported_window_get_type (void) {
	static volatile gsize beat_box_not_imported_window_type_id__volatile = 0;
	if (g_once_init_enter (&beat_box_not_imported_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BeatBoxNotImportedWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beat_box_not_imported_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BeatBoxNotImportedWindow), 0, (GInstanceInitFunc) beat_box_not_imported_window_instance_init, NULL };
		GType beat_box_not_imported_window_type_id;
		beat_box_not_imported_window_type_id = g_type_register_static (GTK_TYPE_WINDOW, "BeatBoxNotImportedWindow", &g_define_type_info, 0);
		g_once_init_leave (&beat_box_not_imported_window_type_id__volatile, beat_box_not_imported_window_type_id);
	}
	return beat_box_not_imported_window_type_id__volatile;
}



