/* DataBaseUpdater.c generated by valac 0.11.7, the Vala compiler
 * generated from DataBaseUpdater.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define BEAT_BOX_TYPE_DATA_BASE_UPDATER (beat_box_data_base_updater_get_type ())
#define BEAT_BOX_DATA_BASE_UPDATER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_DATA_BASE_UPDATER, BeatBoxDataBaseUpdater))
#define BEAT_BOX_DATA_BASE_UPDATER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_DATA_BASE_UPDATER, BeatBoxDataBaseUpdaterClass))
#define BEAT_BOX_IS_DATA_BASE_UPDATER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_DATA_BASE_UPDATER))
#define BEAT_BOX_IS_DATA_BASE_UPDATER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_DATA_BASE_UPDATER))
#define BEAT_BOX_DATA_BASE_UPDATER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_DATA_BASE_UPDATER, BeatBoxDataBaseUpdaterClass))

typedef struct _BeatBoxDataBaseUpdater BeatBoxDataBaseUpdater;
typedef struct _BeatBoxDataBaseUpdaterClass BeatBoxDataBaseUpdaterClass;
typedef struct _BeatBoxDataBaseUpdaterPrivate BeatBoxDataBaseUpdaterPrivate;

#define BEAT_BOX_TYPE_DATA_BASE_MANAGER (beat_box_data_base_manager_get_type ())
#define BEAT_BOX_DATA_BASE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_DATA_BASE_MANAGER, BeatBoxDataBaseManager))
#define BEAT_BOX_DATA_BASE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_DATA_BASE_MANAGER, BeatBoxDataBaseManagerClass))
#define BEAT_BOX_IS_DATA_BASE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_DATA_BASE_MANAGER))
#define BEAT_BOX_IS_DATA_BASE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_DATA_BASE_MANAGER))
#define BEAT_BOX_DATA_BASE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_DATA_BASE_MANAGER, BeatBoxDataBaseManagerClass))

typedef struct _BeatBoxDataBaseManager BeatBoxDataBaseManager;
typedef struct _BeatBoxDataBaseManagerClass BeatBoxDataBaseManagerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define BEAT_BOX_TYPE_SONG (beat_box_song_get_type ())
#define BEAT_BOX_SONG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_SONG, BeatBoxSong))
#define BEAT_BOX_SONG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_SONG, BeatBoxSongClass))
#define BEAT_BOX_IS_SONG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_SONG))
#define BEAT_BOX_IS_SONG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_SONG))
#define BEAT_BOX_SONG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_SONG, BeatBoxSongClass))

typedef struct _BeatBoxSong BeatBoxSong;
typedef struct _BeatBoxSongClass BeatBoxSongClass;

#define BEAT_BOX_TYPE_PLAYLIST (beat_box_playlist_get_type ())
#define BEAT_BOX_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_PLAYLIST, BeatBoxPlaylist))
#define BEAT_BOX_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_PLAYLIST, BeatBoxPlaylistClass))
#define BEAT_BOX_IS_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_PLAYLIST))
#define BEAT_BOX_IS_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_PLAYLIST))
#define BEAT_BOX_PLAYLIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_PLAYLIST, BeatBoxPlaylistClass))

typedef struct _BeatBoxPlaylist BeatBoxPlaylist;
typedef struct _BeatBoxPlaylistClass BeatBoxPlaylistClass;

#define BEAT_BOX_TYPE_SMART_PLAYLIST (beat_box_smart_playlist_get_type ())
#define BEAT_BOX_SMART_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_SMART_PLAYLIST, BeatBoxSmartPlaylist))
#define BEAT_BOX_SMART_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_SMART_PLAYLIST, BeatBoxSmartPlaylistClass))
#define BEAT_BOX_IS_SMART_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_SMART_PLAYLIST))
#define BEAT_BOX_IS_SMART_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_SMART_PLAYLIST))
#define BEAT_BOX_SMART_PLAYLIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_SMART_PLAYLIST, BeatBoxSmartPlaylistClass))

typedef struct _BeatBoxSmartPlaylist BeatBoxSmartPlaylist;
typedef struct _BeatBoxSmartPlaylistClass BeatBoxSmartPlaylistClass;

struct _BeatBoxDataBaseUpdater {
	GObject parent_instance;
	BeatBoxDataBaseUpdaterPrivate * priv;
};

struct _BeatBoxDataBaseUpdaterClass {
	GObjectClass parent_class;
};

struct _BeatBoxDataBaseUpdaterPrivate {
	BeatBoxDataBaseManager* dbm;
	GeeLinkedList* toUpdate;
	GeeLinkedList* toRemove;
	gboolean inThread;
};


static gpointer beat_box_data_base_updater_parent_class = NULL;

GType beat_box_data_base_updater_get_type (void) G_GNUC_CONST;
GType beat_box_data_base_manager_get_type (void) G_GNUC_CONST;
#define BEAT_BOX_DATA_BASE_UPDATER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), BEAT_BOX_TYPE_DATA_BASE_UPDATER, BeatBoxDataBaseUpdaterPrivate))
enum  {
	BEAT_BOX_DATA_BASE_UPDATER_DUMMY_PROPERTY
};
BeatBoxDataBaseUpdater* beat_box_data_base_updater_new (BeatBoxDataBaseManager* databm);
BeatBoxDataBaseUpdater* beat_box_data_base_updater_construct (GType object_type, BeatBoxDataBaseManager* databm);
void beat_box_data_base_updater_updateItem (BeatBoxDataBaseUpdater* self, GObject* item);
void* beat_box_data_base_updater_update_db_thread_function (BeatBoxDataBaseUpdater* self);
static gpointer _beat_box_data_base_updater_update_db_thread_function_gthread_func (gpointer self);
void beat_box_data_base_updater_removeItem (BeatBoxDataBaseUpdater* self, GObject* item);
GType beat_box_song_get_type (void) G_GNUC_CONST;
void beat_box_data_base_manager_update_songs (BeatBoxDataBaseManager* self, GeeCollection* songs);
GType beat_box_playlist_get_type (void) G_GNUC_CONST;
void beat_box_data_base_manager_update_playlist (BeatBoxDataBaseManager* self, BeatBoxPlaylist* p);
GType beat_box_smart_playlist_get_type (void) G_GNUC_CONST;
void beat_box_data_base_manager_update_smart_playlist (BeatBoxDataBaseManager* self, BeatBoxSmartPlaylist* p);
void beat_box_data_base_manager_remove_songs (BeatBoxDataBaseManager* self, GeeCollection* songs);
static void beat_box_data_base_updater_finalize (GObject* obj);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


BeatBoxDataBaseUpdater* beat_box_data_base_updater_construct (GType object_type, BeatBoxDataBaseManager* databm) {
	BeatBoxDataBaseUpdater * self = NULL;
	BeatBoxDataBaseManager* _tmp0_;
	GeeLinkedList* _tmp1_ = NULL;
	GeeLinkedList* _tmp2_ = NULL;
	g_return_val_if_fail (databm != NULL, NULL);
	self = (BeatBoxDataBaseUpdater*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (databm);
	_g_object_unref0 (self->priv->dbm);
	self->priv->dbm = _tmp0_;
	_tmp1_ = gee_linked_list_new (G_TYPE_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->priv->toUpdate);
	self->priv->toUpdate = _tmp1_;
	_tmp2_ = gee_linked_list_new (G_TYPE_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->priv->toRemove);
	self->priv->toRemove = _tmp2_;
	self->priv->inThread = FALSE;
	return self;
}


BeatBoxDataBaseUpdater* beat_box_data_base_updater_new (BeatBoxDataBaseManager* databm) {
	return beat_box_data_base_updater_construct (BEAT_BOX_TYPE_DATA_BASE_UPDATER, databm);
}


static gpointer _beat_box_data_base_updater_update_db_thread_function_gthread_func (gpointer self) {
	gpointer result;
	result = beat_box_data_base_updater_update_db_thread_function (self);
	return result;
}


void beat_box_data_base_updater_updateItem (BeatBoxDataBaseUpdater* self, GObject* item) {
	gboolean _tmp0_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (item != NULL);
	_tmp0_ = gee_abstract_collection_contains ((GeeAbstractCollection*) self->priv->toUpdate, item);
	if (!_tmp0_) {
		gee_queue_offer ((GeeQueue*) self->priv->toUpdate, item);
	}
	if (!self->priv->inThread) {
		self->priv->inThread = TRUE;
		g_thread_create (_beat_box_data_base_updater_update_db_thread_function_gthread_func, self, FALSE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_THREAD_ERROR) {
				goto __catch26_g_thread_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		goto __finally26;
		__catch26_g_thread_error:
		{
			GError * err;
			err = _inner_error_;
			_inner_error_ = NULL;
			fprintf (stdout, "Could not create thread to update database: %s \n", err->message);
			_g_error_free0 (err);
		}
		__finally26:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


void beat_box_data_base_updater_removeItem (BeatBoxDataBaseUpdater* self, GObject* item) {
	gboolean _tmp0_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (item != NULL);
	_tmp0_ = gee_abstract_collection_contains ((GeeAbstractCollection*) self->priv->toRemove, item);
	if (!_tmp0_) {
		gee_queue_offer ((GeeQueue*) self->priv->toRemove, item);
	}
	if (!self->priv->inThread) {
		self->priv->inThread = TRUE;
		g_thread_create (_beat_box_data_base_updater_update_db_thread_function_gthread_func, self, FALSE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_THREAD_ERROR) {
				goto __catch27_g_thread_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		goto __finally27;
		__catch27_g_thread_error:
		{
			GError * err;
			err = _inner_error_;
			_inner_error_ = NULL;
			fprintf (stdout, "Could not create thread to update database: %s \n", err->message);
			_g_error_free0 (err);
		}
		__finally27:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


void* beat_box_data_base_updater_update_db_thread_function (BeatBoxDataBaseUpdater* self) {
	void* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	while (TRUE) {
		GObject* next = NULL;
		gpointer _tmp0_ = NULL;
		_tmp0_ = gee_queue_poll ((GeeQueue*) self->priv->toUpdate);
		_g_object_unref0 (next);
		next = (GObject*) _tmp0_;
		if (next != NULL) {
			if (GEE_IS_LINKED_LIST (next)) {
				beat_box_data_base_manager_update_songs (self->priv->dbm, (GeeCollection*) GEE_LINKED_LIST (next));
			} else {
				if (BEAT_BOX_IS_PLAYLIST (next)) {
					beat_box_data_base_manager_update_playlist (self->priv->dbm, BEAT_BOX_PLAYLIST (next));
				} else {
					if (BEAT_BOX_IS_SMART_PLAYLIST (next)) {
						beat_box_data_base_manager_update_smart_playlist (self->priv->dbm, BEAT_BOX_SMART_PLAYLIST (next));
					}
				}
			}
		} else {
			gpointer _tmp1_ = NULL;
			_tmp1_ = gee_queue_poll ((GeeQueue*) self->priv->toRemove);
			_g_object_unref0 (next);
			next = (GObject*) _tmp1_;
			if (next != NULL) {
				if (GEE_IS_LINKED_LIST (next)) {
					beat_box_data_base_manager_remove_songs (self->priv->dbm, (GeeCollection*) GEE_LINKED_LIST (next));
				}
			} else {
				self->priv->inThread = FALSE;
				result = NULL;
				_g_object_unref0 (next);
				return result;
			}
		}
		_g_object_unref0 (next);
	}
}


static void beat_box_data_base_updater_class_init (BeatBoxDataBaseUpdaterClass * klass) {
	beat_box_data_base_updater_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BeatBoxDataBaseUpdaterPrivate));
	G_OBJECT_CLASS (klass)->finalize = beat_box_data_base_updater_finalize;
}


static void beat_box_data_base_updater_instance_init (BeatBoxDataBaseUpdater * self) {
	self->priv = BEAT_BOX_DATA_BASE_UPDATER_GET_PRIVATE (self);
}


static void beat_box_data_base_updater_finalize (GObject* obj) {
	BeatBoxDataBaseUpdater * self;
	self = BEAT_BOX_DATA_BASE_UPDATER (obj);
	_g_object_unref0 (self->priv->dbm);
	_g_object_unref0 (self->priv->toUpdate);
	_g_object_unref0 (self->priv->toRemove);
	G_OBJECT_CLASS (beat_box_data_base_updater_parent_class)->finalize (obj);
}


GType beat_box_data_base_updater_get_type (void) {
	static volatile gsize beat_box_data_base_updater_type_id__volatile = 0;
	if (g_once_init_enter (&beat_box_data_base_updater_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BeatBoxDataBaseUpdaterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beat_box_data_base_updater_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BeatBoxDataBaseUpdater), 0, (GInstanceInitFunc) beat_box_data_base_updater_instance_init, NULL };
		GType beat_box_data_base_updater_type_id;
		beat_box_data_base_updater_type_id = g_type_register_static (G_TYPE_OBJECT, "BeatBoxDataBaseUpdater", &g_define_type_info, 0);
		g_once_init_leave (&beat_box_data_base_updater_type_id__volatile, beat_box_data_base_updater_type_id);
	}
	return beat_box_data_base_updater_type_id__volatile;
}



