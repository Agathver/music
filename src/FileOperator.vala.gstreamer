/*-
 * Copyright (c) 2011-2012       Scott Ringwelski <sgringwe@mtu.edu>
 *
 * Originally Written by Scott Ringwelski for BeatBox Music Player
 * BeatBox Music Player: http://www.launchpad.net/beat-box
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

using TagLib;
using GLib;
using Gee;
using Gst;

public class BeatBox.FileOperator : GLib.Object {
	private BeatBox.LibraryManager lm;
	private BeatBox.Settings settings;
	private BeatBox.GstreamerTagger tagger;
	
	bool inThread;
	LinkedList<Media> toSave;
	
	public int index;
	public int item_count;
	public signal void fo_progress(string? message, double progress);
	
	public FileOperator(BeatBox.LibraryManager lmm, BeatBox.Settings sett) {
		lm = lmm;
		settings = sett;
		tagger = new GstreamerTagger();
		
		inThread = false;
		toSave = new LinkedList<Media>();
	}
	
	public void resetProgress(int items) {
		index = 0;
		item_count = items;
	}
	
	private static bool is_valid_file_type(string type) {
		var typeDown = type.down();
		
		return (typeDown.has_suffix(".mp3") || typeDown.has_suffix(".m4a") || 
				typeDown.has_suffix(".wma") || typeDown.has_suffix(".ogg") || 
				typeDown.has_suffix(".flac") || typeDown.has_suffix(".mp4") || 
				typeDown.has_suffix(".oga") || typeDown.has_suffix(".m4p") ||
				typeDown.has_suffix(".aac") || typeDown.has_suffix(".alac"));
	}
	
	private static bool is_valid_image_type(string type) {
		var typeDown = type.down();
		
		return (typeDown.has_suffix(".jpg") || typeDown.has_suffix(".jpeg") ||
				typeDown.has_suffix(".png"));
	}
	
	public int count_music_files(GLib.File music_folder) {
		GLib.FileInfo file_info = null;
		
		try {
			var enumerator = music_folder.enumerate_children(FILE_ATTRIBUTE_STANDARD_NAME + "," + FILE_ATTRIBUTE_STANDARD_TYPE, 0);
			while ((file_info = enumerator.next_file ()) != null) {
				var file_path = music_folder.get_path() + "/" + file_info.get_name();
				
				if(file_info.get_file_type() == GLib.FileType.REGULAR && is_valid_file_type(file_info.get_name())) {
					index++;
				}
				else if(file_info.get_file_type() == GLib.FileType.DIRECTORY)
					count_music_files(GLib.File.new_for_path(file_path));
			}
		}
		catch(GLib.Error err) {
			stdout.printf("Could not pre-scan music folder. Progress percentage may be off: %s\n", err.message);
		}
        
        return index;
	}
	
	public void get_music_files(GLib.File music_folder, ref LinkedList<Media> medias, ref LinkedList<string> not_imported) {
		GLib.FileInfo file_info = null;
		string artPath = "";
		
		try {
			var enumerator = music_folder.enumerate_children(FILE_ATTRIBUTE_STANDARD_NAME + "," + FILE_ATTRIBUTE_STANDARD_TYPE, 0);
			while ((file_info = enumerator.next_file ()) != null) {
				var file_path = music_folder.get_path() + "/" + file_info.get_name();
				
				if(file_info.get_file_type() == GLib.FileType.REGULAR && is_valid_image_type(file_info.get_name())) {
					artPath = file_path;
					break;
				}
			}
				
			enumerator = music_folder.enumerate_children(FILE_ATTRIBUTE_STANDARD_NAME + "," + FILE_ATTRIBUTE_STANDARD_TYPE, 0);
			while ((file_info = enumerator.next_file ()) != null) {
				var file_path = music_folder.get_path() + "/" + file_info.get_name();
				
				if(file_info.get_file_type() == GLib.FileType.REGULAR && is_valid_file_type(file_info.get_name())) {
					++index;
					
					Media s = tagger.import_media(GLib.File.new_for_path(file_path));
					
					if(s != null) {
						medias.add(s);
						s.setAlbumArtPath(artPath);
					}
					else
						not_imported.add(file_path);
				}
				else if(file_info.get_file_type() == GLib.FileType.DIRECTORY){
					get_music_files(GLib.File.new_for_path(file_path), ref medias, ref not_imported);
				}
			}
		}
		catch(GLib.Error err) {
			stdout.printf("Could not get music: %s\n", err.message);
		}
	}
	
	public void get_music_files_individually(LinkedList<string> files, ref LinkedList<Media> medias, ref LinkedList<string> not_imported) {
		foreach(string file in files) {
			try {
				GLib.File gio_file = GLib.File.new_for_uri(file);
				FileInfo file_info = gio_file.query_info("*", FileQueryInfoFlags.NONE);
				string file_path = gio_file.get_path();
				
				if(file_info.get_file_type() == GLib.FileType.REGULAR && is_valid_file_type(file_info.get_name())) {
					++index;
					
					Media s = tagger.import_media(GLib.File.new_for_path(file_path));
					
					if(s != null) {
						medias.add(s);
					}
					else
						not_imported.add(file_path);
				}
				else if(file_info.get_file_type() == GLib.FileType.DIRECTORY){
					get_music_files(GLib.File.new_for_path(file_path), ref medias, ref not_imported);
				}
			}
			catch(GLib.Error err) {
				stdout.printf("Could not get media %s: %s\n", file, err.message);
			}
		}
	}
        
	/** rescans the music folder to update the db to the folder situation.
	 * If media is in folder, and in db, re-add
	 * If media is not in folder and in db,remove
	 * If media is in both, do nothing.
	 * @param music_folder The folder to rescan
	 * @param current_media_paths Paths of files already in db. once file
	 * is re-added, set string to "ADDED". at end, remove all medias that
	 * are not re-added.
	 * @return file paths of medias no longer available. TODO: should out that
	 */
	public void rescan_music(GLib.File music_folder, ref LinkedList<string> current_media_paths, ref LinkedList<string> not_imported, ref LinkedList<Media> new_medias) {
		GLib.FileInfo file_info = null;
		string current_artist = "";
		string current_album = ""; // these are purposely reset on recursive call
		string artPath = "";
		
		int medias_added = 0;
		try {
			var enumerator = music_folder.enumerate_children(FILE_ATTRIBUTE_STANDARD_NAME + "," + FILE_ATTRIBUTE_STANDARD_TYPE, 0);
			while ((file_info = enumerator.next_file ()) != null) {
				var file_path = music_folder.get_path() + "/" + file_info.get_name();
				
				if(file_info.get_file_type() == GLib.FileType.REGULAR && is_valid_image_type(file_info.get_name())) {
					artPath = file_path;
					break;
				}
			}
				
			enumerator = music_folder.enumerate_children(FILE_ATTRIBUTE_STANDARD_NAME + "," + FILE_ATTRIBUTE_STANDARD_TYPE, 0);
			while ((file_info = enumerator.next_file ()) != null) {
				var file_path = music_folder.get_path() + "/" + file_info.get_name();
				
				if(file_info.get_file_type() == GLib.FileType.REGULAR && is_valid_file_type(file_info.get_name())) {
					if(current_media_paths.contains(file_path)) {
						current_media_paths.remove(file_path);
						
							
						++index;
					}
					else if(!current_media_paths.contains(file_path)) {
						Media s = tagger.import_media(GLib.File.new_for_path(file_path));
						
						if(s != null) {
							new_medias.add(s);
							current_artist = s.artist;
							current_album = s.album;
							
							s.setAlbumArtPath(artPath);
						}
						else
							not_imported.add(file_path);
						
						++medias_added;
					}
				}
				else if(file_info.get_file_type() == GLib.FileType.DIRECTORY){
					rescan_music(GLib.File.new_for_path(file_path), ref current_media_paths, ref not_imported, ref new_medias);
				}
			}
		}
		catch(GLib.Error err) {
			stdout.printf("Could not rescan music folder: %s\n", err.message);
		}
	}
	
	
	public Gdk.Pixbuf? save_album(Media s, string uri) {
		Gdk.Pixbuf rv;
		
		if(uri == null || uri == "") {
			return null;
		}
		
		GLib.File file = GLib.File.new_for_uri(uri);
		if(file == null) {
			return null;
		}
		
		FileInputStream filestream;
		
		try {
			filestream = file.read(null);
			rv = new Gdk.Pixbuf.from_stream(filestream, null);
			var dest = Path.build_path("/", GLib.File.new_for_path(s.file).get_parent().get_path(), "Album.jpg");
			rv.save(dest, "jpeg");
			
			Gee.LinkedList<Media> updated_medias = new Gee.LinkedList<Media>();
			foreach(int i in lm.media_ids()) {
				if(lm.media_from_id(i).artist == s.artist && lm.media_from_id(i).album == s.album) {
					stdout.printf("setting album art for %s by %s\n", lm.media_from_id(i).title, lm.media_from_id(i).artist);
					lm.media_from_id(i).setAlbumArtPath(dest);
					updated_medias.add(lm.media_from_id(i));
				}
			}
			
			lm.update_medias(updated_medias, false);
			
			// for sound menu (dbus doesn't like linked lists)
			if(updated_medias.contains(lm.media_info.media))
				lm.update_media(lm.media_info.media, false);
		}
		catch(GLib.Error err) {
			rv = null;
		}
		
		return rv;
	}
	
	public Gdk.Pixbuf? save_artist_image(Media s, string uri) {
		Gdk.Pixbuf rv;
		
		if(uri == null || uri == "") {
			return null;
		}
		
		GLib.File file = GLib.File.new_for_uri(uri);
		FileInputStream filestream;
		
		try {
			filestream = file.read(null);
			rv = new Gdk.Pixbuf.from_stream(filestream, null);
			rv.save(Path.build_path("/", GLib.File.new_for_path(s.file).get_parent().get_parent().get_path(), "Artist.jpg"), "jpeg");
		}
		catch(GLib.Error err) {
			rv = null;
		}
		
		return rv;
	}
	
	public void save_medias(Collection<Media> to_save) {
		foreach(Media s in to_save) {
			if(!(toSave.contains(s)))
				toSave.offer(s);
		}
		
		if(!inThread) {
			try {
				inThread = true;
				Thread.create<void*>(save_media_thread, false);
			}
			catch(GLib.Error err) {
				stdout.printf("Could not create thread to rescan music folder: %s\n", err.message);
			}
		}
	}
        
	public void* save_media_thread () {
		while(true) {
			Media s = toSave.poll();
			
			if(s == null) {
				inThread = false;
				return null;
			}
			
			
			
			if(settings.getUpdateFolderHierarchy())
				update_file_hierarchy(s, true);
		}
	}
	
	public void update_file_hierarchy(Media s, bool delete_old) {
		try {
			/* initialize file objects */
			var original = GLib.File.new_for_path(s.file);
			var ext = get_extension(s.file);
			var file_info = original.query_info ("*", FileQueryInfoFlags.NONE, null);
			
			GLib.File dest;
			string extra = "";
			while((dest = GLib.File.new_for_path(Path.build_path("/", settings.getMusicFolder(), s.artist.replace("/", "_"), s.album.replace("/", "_"), s.track.to_string() + " " + s.title.replace("/", "_") + extra + ext))).query_exists()) {
				extra += "_";
			}
			
			if(original.get_path() == dest.get_path())
				return;
				
			stdout.printf("\n\n");
			
			/* make sure that the parent folders exist */
			if(!dest.get_parent().get_parent().query_exists()) {
				stdout.printf("artist folder %s does not exist\n", dest.get_parent().get_parent().get_path());
				
				try {
					dest.get_parent().get_parent().make_directory(null);
					dest.get_parent().make_directory(null);
				}
				catch(GLib.Error err) {
					stdout.printf("Could not create folder to copy to: %s\n", err.message);
					// does it make sense to return here?
				}
			}
			else if(!dest.get_parent().query_exists()) {
				stdout.printf("album folder %s does not exist\n", dest.get_parent().get_path());
				
				try {
					dest.get_parent().make_directory(null);
				}
				catch(GLib.Error err) {
					stdout.printf("Could not create folder to copy to: %s\n", err.message);
					// does it make sense to return here?
				}
			}
			
			/* copy the file over */
			bool success = false;
			if(!delete_old) {
				stdout.printf("Copying %s to %s\n", s.file, dest.get_path());
				success = original.copy(dest, FileCopyFlags.NONE, null, null);
			}
			else {
				stdout.printf("Moving %s to %s\n", s.file, dest.get_path());
				success = original.move(dest, FileCopyFlags.NONE, null, null);
			}
			
			if(success) {
				s.file = dest.get_path();
				lm.update_media(s, false); // make sure that the media's file path is updated in db.
				
				if(s.getAlbumArtPath().contains(original.get_parent().get_path())) {
					var mediaFile = GLib.File.new_for_path(s.getAlbumArtPath());
					var albumArtDest = Path.build_path("/", dest.get_parent().get_path(), "Album.jpg");
					
					if(!GLib.File.new_for_path(albumArtDest).query_exists() && mediaFile.query_exists() &&
					mediaFile.copy(GLib.File.new_for_path(albumArtDest), FileCopyFlags.NONE, null, null)) {
						stdout.printf("Copying album art to %s\n", albumArtDest);
						s.setAlbumArtPath(albumArtDest);
					}
				}
			}
			else
				stdout.printf("Failure: Could not copy imported media %s to media folder %s\n", s.file, dest.get_path());
			
			/* if we are supposed to delete the old, make sure there are no items left in folder if we do */
			if(delete_old) {
				var old_folder_items = count_music_files(original.get_parent());
				// must check for .jpg's as well.
				
				if(old_folder_items == 0) {
					stdout.printf("going to delete %s because no files are in it\n", original.get_parent().get_path());
					original.get_parent().delete();
				}
			}
		}
		catch(GLib.Error err) {
			stdout.printf("Could not copy imported media %s to media folder: %s\n", s.file, err.message);
		}
	}
	
	public void remove_medias(Collection<string> toRemove) {
		foreach(string s in toRemove) {
			try {
				var file = GLib.File.new_for_path(s);
				file.trash();
				
				var old_folder_items = count_music_files(file.get_parent());
					
				//TODO: COPY ALBUM AND IMAGE ARTWORK
				if(old_folder_items == 0) {
					stdout.printf("going to delete %s because no files are in it\n", file.get_parent().get_path());
					//original.get_parent().delete();
					
					var old_folder_parent_items = count_music_files(file.get_parent().get_parent());
					
					if(old_folder_parent_items == 0) {
						stdout.printf("going to delete %s because no files are in it\n", file.get_parent().get_parent().get_path());
					}
				}
			}
			catch(GLib.Error err) {
				stdout.printf("Could not move file %s to trash: %s (you could be using a file system which is not supported)\n", s, err.message);
				
				//tell the user the file could not be moved and ask if they'd like to delete permanently instead.
				Gtk.MessageDialog md = new Gtk.MessageDialog(lm.lw, Gtk.DialogFlags.MODAL, Gtk.MessageType.QUESTION, Gtk.ButtonsType.YES_NO, "Could not trash file %s, would you like to permanently delete it? You cannot undo these changes.", s);
			}
		}
	}
	
	public static void guess_content_type(GLib.File root, ref int audio, ref int other) {
		GLib.FileInfo file_info = null;
		
		try {
			var enumerator = root.enumerate_children(FILE_ATTRIBUTE_STANDARD_NAME + "," + FILE_ATTRIBUTE_STANDARD_TYPE, 0);
			while ((file_info = enumerator.next_file ()) != null) {
				var file_path = root.get_path() + "/" + file_info.get_name();
				
				if(file_info.get_file_type() == GLib.FileType.REGULAR && is_valid_file_type(file_info.get_name())) {
					++audio;
				}
				else if(file_info.get_file_type() == GLib.FileType.REGULAR) {
					++other;
				}
				else if(file_info.get_file_type() == GLib.FileType.DIRECTORY)
					guess_content_type(GLib.File.new_for_path(file_path), ref audio, ref other);
			}
		}
		catch(GLib.Error err) {
			stdout.printf("Could not guess content types: %s\n", err.message);
		}
	}
	
	public string get_extension(string name) {
		return name.slice(name.last_index_of(".", 0), name.length);
	}
}
