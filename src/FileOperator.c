/* FileOperator.c generated by valac 0.11.6, the Vala compiler
 * generated from FileOperator.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>
#include <gee.h>
#include <float.h>
#include <math.h>
#include <tag_c.h>
#include <time.h>
#include <gdk-pixbuf/gdk-pixdata.h>


#define BEAT_BOX_TYPE_FILE_OPERATOR (beat_box_file_operator_get_type ())
#define BEAT_BOX_FILE_OPERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperator))
#define BEAT_BOX_FILE_OPERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperatorClass))
#define BEAT_BOX_IS_FILE_OPERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_FILE_OPERATOR))
#define BEAT_BOX_IS_FILE_OPERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_FILE_OPERATOR))
#define BEAT_BOX_FILE_OPERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperatorClass))

typedef struct _BeatBoxFileOperator BeatBoxFileOperator;
typedef struct _BeatBoxFileOperatorClass BeatBoxFileOperatorClass;
typedef struct _BeatBoxFileOperatorPrivate BeatBoxFileOperatorPrivate;

#define BEAT_BOX_TYPE_LIBRARY_MANAGER (beat_box_library_manager_get_type ())
#define BEAT_BOX_LIBRARY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_LIBRARY_MANAGER, BeatBoxLibraryManager))
#define BEAT_BOX_LIBRARY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_LIBRARY_MANAGER, BeatBoxLibraryManagerClass))
#define BEAT_BOX_IS_LIBRARY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_LIBRARY_MANAGER))
#define BEAT_BOX_IS_LIBRARY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_LIBRARY_MANAGER))
#define BEAT_BOX_LIBRARY_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_LIBRARY_MANAGER, BeatBoxLibraryManagerClass))

typedef struct _BeatBoxLibraryManager BeatBoxLibraryManager;
typedef struct _BeatBoxLibraryManagerClass BeatBoxLibraryManagerClass;

#define BEAT_BOX_TYPE_SETTINGS (beat_box_settings_get_type ())
#define BEAT_BOX_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettings))
#define BEAT_BOX_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettingsClass))
#define BEAT_BOX_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_SETTINGS))
#define BEAT_BOX_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_SETTINGS))
#define BEAT_BOX_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_SETTINGS, BeatBoxSettingsClass))

typedef struct _BeatBoxSettings BeatBoxSettings;
typedef struct _BeatBoxSettingsClass BeatBoxSettingsClass;

#define BEAT_BOX_TYPE_SONG (beat_box_song_get_type ())
#define BEAT_BOX_SONG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BEAT_BOX_TYPE_SONG, BeatBoxSong))
#define BEAT_BOX_SONG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BEAT_BOX_TYPE_SONG, BeatBoxSongClass))
#define BEAT_BOX_IS_SONG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BEAT_BOX_TYPE_SONG))
#define BEAT_BOX_IS_SONG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BEAT_BOX_TYPE_SONG))
#define BEAT_BOX_SONG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BEAT_BOX_TYPE_SONG, BeatBoxSongClass))

typedef struct _BeatBoxSong BeatBoxSong;
typedef struct _BeatBoxSongClass BeatBoxSongClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _taglib_file_free0(var) ((var == NULL) ? NULL : (var = (taglib_file_free (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

struct _BeatBoxFileOperator {
	GObject parent_instance;
	BeatBoxFileOperatorPrivate * priv;
};

struct _BeatBoxFileOperatorClass {
	GObjectClass parent_class;
};

struct _BeatBoxFileOperatorPrivate {
	BeatBoxLibraryManager* lm;
	BeatBoxSettings* settings;
	BeatBoxSong* temp_song;
	gint index;
	gint item_count;
};


static gpointer beat_box_file_operator_parent_class = NULL;

GType beat_box_file_operator_get_type (void) G_GNUC_CONST;
GType beat_box_library_manager_get_type (void) G_GNUC_CONST;
GType beat_box_settings_get_type (void) G_GNUC_CONST;
GType beat_box_song_get_type (void) G_GNUC_CONST;
#define BEAT_BOX_FILE_OPERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), BEAT_BOX_TYPE_FILE_OPERATOR, BeatBoxFileOperatorPrivate))
enum  {
	BEAT_BOX_FILE_OPERATOR_DUMMY_PROPERTY
};
BeatBoxFileOperator* beat_box_file_operator_new (BeatBoxLibraryManager* lmm, BeatBoxSettings* sett);
BeatBoxFileOperator* beat_box_file_operator_construct (GType object_type, BeatBoxLibraryManager* lmm, BeatBoxSettings* sett);
void beat_box_file_operator_resetProgress (BeatBoxFileOperator* self, gint items);
static gboolean beat_box_file_operator_is_valid_file_type (BeatBoxFileOperator* self, const gchar* type);
gint beat_box_file_operator_count_music_files (BeatBoxFileOperator* self, GFile* music_folder);
void beat_box_file_operator_get_music_files (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** songs, GeeLinkedList** not_imported);
BeatBoxSong* beat_box_file_operator_import_song (BeatBoxFileOperator* self, const gchar* file_path);
void beat_box_file_operator_rescan_music (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** current_song_paths, GeeLinkedList** not_imported, GeeLinkedList** new_songs);
void beat_box_library_manager_add_song (BeatBoxLibraryManager* self, BeatBoxSong* s);
BeatBoxSong* beat_box_song_new (const gchar* file);
BeatBoxSong* beat_box_song_construct (GType object_type, const gchar* file);
void beat_box_song_set_title (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_artist (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_album (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_genre (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_comment (BeatBoxSong* self, const gchar* value);
void beat_box_song_set_year (BeatBoxSong* self, gint value);
void beat_box_song_set_track (BeatBoxSong* self, gint value);
void beat_box_song_set_bitrate (BeatBoxSong* self, gint value);
void beat_box_song_set_length (BeatBoxSong* self, gint value);
void beat_box_song_set_samplerate (BeatBoxSong* self, gint value);
void beat_box_song_set_date_added (BeatBoxSong* self, gint value);
const gchar* beat_box_song_get_title (BeatBoxSong* self);
const gchar* beat_box_song_get_artist (BeatBoxSong* self);
static gboolean beat_box_file_operator_is_image_file_type (BeatBoxFileOperator* self, const gchar* type);
gchar* beat_box_file_operator_get_folder (const gchar* file);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
gchar* beat_box_file_operator_find_album (BeatBoxFileOperator* self, BeatBoxSong* s);
const gchar* beat_box_song_get_file (BeatBoxSong* self);
const gchar* beat_box_song_get_album (BeatBoxSong* self);
GdkPixbuf* beat_box_file_operator_save_album (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri);
gchar* beat_box_file_operator_find_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s);
GdkPixbuf* beat_box_file_operator_save_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri);
void beat_box_file_operator_save_song (BeatBoxFileOperator* self, BeatBoxSong* s);
void* beat_box_file_operator_save_song_thread (BeatBoxFileOperator* self);
static gpointer _beat_box_file_operator_save_song_thread_gthread_func (gpointer self);
const gchar* beat_box_song_get_genre (BeatBoxSong* self);
const gchar* beat_box_song_get_comment (BeatBoxSong* self);
gint beat_box_song_get_year (BeatBoxSong* self);
gint beat_box_song_get_track (BeatBoxSong* self);
void beat_box_file_operator_update_file_hierarchy (BeatBoxFileOperator* self, BeatBoxSong* s);
static void g_cclosure_user_marshal_VOID__STRING_DOUBLE (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void beat_box_file_operator_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


BeatBoxFileOperator* beat_box_file_operator_construct (GType object_type, BeatBoxLibraryManager* lmm, BeatBoxSettings* sett) {
	BeatBoxFileOperator * self = NULL;
	BeatBoxLibraryManager* _tmp0_;
	BeatBoxLibraryManager* _tmp1_;
	BeatBoxSettings* _tmp2_;
	BeatBoxSettings* _tmp3_;
	g_return_val_if_fail (lmm != NULL, NULL);
	g_return_val_if_fail (sett != NULL, NULL);
	self = (BeatBoxFileOperator*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (lmm);
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->lm);
	self->priv->lm = _tmp1_;
	_tmp2_ = _g_object_ref0 (sett);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp3_;
	return self;
}


BeatBoxFileOperator* beat_box_file_operator_new (BeatBoxLibraryManager* lmm, BeatBoxSettings* sett) {
	return beat_box_file_operator_construct (BEAT_BOX_TYPE_FILE_OPERATOR, lmm, sett);
}


void beat_box_file_operator_resetProgress (BeatBoxFileOperator* self, gint items) {
	g_return_if_fail (self != NULL);
	self->priv->index = 0;
	self->priv->item_count = items;
}


static gboolean beat_box_file_operator_is_valid_file_type (BeatBoxFileOperator* self, const gchar* type) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gboolean _tmp7_;
	gboolean _tmp8_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (type != NULL, FALSE);
	_tmp5_ = g_utf8_strdown (type, (gssize) (-1));
	_tmp6_ = _tmp5_;
	_tmp7_ = g_str_has_suffix (_tmp6_, ".mp3");
	if ((_tmp8_ = _tmp7_, _g_free0 (_tmp6_), _tmp8_)) {
		_tmp4_ = TRUE;
	} else {
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		gboolean _tmp11_;
		_tmp9_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp10_ = _tmp9_;
		_tmp11_ = g_str_has_suffix (_tmp10_, ".m4a");
		_tmp4_ = _tmp11_;
		_g_free0 (_tmp10_);
	}
	if (_tmp4_) {
		_tmp3_ = TRUE;
	} else {
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_;
		gboolean _tmp14_;
		_tmp12_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp13_ = _tmp12_;
		_tmp14_ = g_str_has_suffix (_tmp13_, ".wma");
		_tmp3_ = _tmp14_;
		_g_free0 (_tmp13_);
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_;
		gboolean _tmp17_;
		_tmp15_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp16_ = _tmp15_;
		_tmp17_ = g_str_has_suffix (_tmp16_, ".ogg");
		_tmp2_ = _tmp17_;
		_g_free0 (_tmp16_);
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_;
		gboolean _tmp20_;
		_tmp18_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp19_ = _tmp18_;
		_tmp20_ = g_str_has_suffix (_tmp19_, ".flac");
		_tmp1_ = _tmp20_;
		_g_free0 (_tmp19_);
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_;
		gboolean _tmp23_;
		_tmp21_ = g_utf8_strdown (type, (gssize) (-1));
		_tmp22_ = _tmp21_;
		_tmp23_ = g_str_has_suffix (_tmp22_, ".mp4");
		_tmp0_ = _tmp23_;
		_g_free0 (_tmp22_);
	}
	result = _tmp0_;
	return result;
}


gint beat_box_file_operator_count_music_files (BeatBoxFileOperator* self, GFile* music_folder) {
	gint result = 0;
	GFileInfo* file_info;
	GFileEnumerator* _tmp0_ = NULL;
	GFileEnumerator* enumerator;
	gint _tmp16_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (music_folder != NULL, 0);
	file_info = NULL;
	_tmp0_ = g_file_enumerate_children (music_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch24_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp1_ = NULL;
		GFileInfo* _tmp2_;
		GFileInfo* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* file_path;
		gboolean _tmp9_ = FALSE;
		GFileType _tmp10_;
		_tmp1_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch24_g_error;
		}
		_tmp3_ = _tmp2_;
		_g_object_unref0 (file_info);
		file_info = _tmp3_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp4_ = g_file_get_path (music_folder);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_strconcat (_tmp5_, "/", NULL);
		_tmp7_ = g_file_info_get_name (file_info);
		file_path = (_tmp8_ = g_strconcat (_tmp6_, _tmp7_, NULL), _g_free0 (_tmp6_), _g_free0 (_tmp5_), _tmp8_);
		_tmp10_ = g_file_info_get_file_type (file_info);
		if (_tmp10_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp11_ = NULL;
			gboolean _tmp12_;
			_tmp11_ = g_file_info_get_name (file_info);
			_tmp12_ = beat_box_file_operator_is_valid_file_type (self, _tmp11_);
			_tmp9_ = _tmp12_;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			self->priv->index++;
		} else {
			GFileType _tmp13_;
			_tmp13_ = g_file_info_get_file_type (file_info);
			if (_tmp13_ == G_FILE_TYPE_DIRECTORY) {
				GFile* _tmp14_ = NULL;
				GFile* _tmp15_;
				_tmp14_ = g_file_new_for_path (file_path);
				_tmp15_ = _tmp14_;
				beat_box_file_operator_count_music_files (self, _tmp15_);
				_g_object_unref0 (_tmp15_);
			}
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally24;
	__catch24_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not pre-scan music folder. Progress percentage may be off: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally24:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	if (self->priv->index != 0) {
		_tmp16_ = self->priv->index;
	} else {
		_tmp16_ = 1000;
	}
	result = _tmp16_;
	_g_object_unref0 (file_info);
	return result;
}


void beat_box_file_operator_get_music_files (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** songs, GeeLinkedList** not_imported) {
	GFileInfo* file_info;
	GFileEnumerator* _tmp0_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (music_folder != NULL);
	g_return_if_fail (songs != NULL);
	g_return_if_fail (not_imported != NULL);
	file_info = NULL;
	_tmp0_ = g_file_enumerate_children (music_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch25_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp1_ = NULL;
		GFileInfo* _tmp2_;
		GFileInfo* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* file_path;
		gboolean _tmp9_ = FALSE;
		GFileType _tmp10_;
		_tmp1_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch25_g_error;
		}
		_tmp3_ = _tmp2_;
		_g_object_unref0 (file_info);
		file_info = _tmp3_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp4_ = g_file_get_path (music_folder);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_strconcat (_tmp5_, "/", NULL);
		_tmp7_ = g_file_info_get_name (file_info);
		file_path = (_tmp8_ = g_strconcat (_tmp6_, _tmp7_, NULL), _g_free0 (_tmp6_), _g_free0 (_tmp5_), _tmp8_);
		_tmp10_ = g_file_info_get_file_type (file_info);
		if (_tmp10_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp11_ = NULL;
			gboolean _tmp12_;
			_tmp11_ = g_file_info_get_name (file_info);
			_tmp12_ = beat_box_file_operator_is_valid_file_type (self, _tmp11_);
			_tmp9_ = _tmp12_;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			BeatBoxSong* _tmp13_ = NULL;
			BeatBoxSong* s;
			self->priv->index = self->priv->index + 1;
			g_signal_emit_by_name (self, "fo-progress", NULL, ((gdouble) ((gdouble) self->priv->index)) / ((gdouble) self->priv->item_count));
			_tmp13_ = beat_box_file_operator_import_song (self, file_path);
			s = _tmp13_;
			if (s != NULL) {
				gee_abstract_collection_add ((GeeAbstractCollection*) (*songs), s);
			} else {
				gee_abstract_collection_add ((GeeAbstractCollection*) (*not_imported), file_path);
			}
			_g_object_unref0 (s);
		} else {
			GFileType _tmp14_;
			_tmp14_ = g_file_info_get_file_type (file_info);
			if (_tmp14_ == G_FILE_TYPE_DIRECTORY) {
				GFile* _tmp15_ = NULL;
				GFile* _tmp16_;
				_tmp15_ = g_file_new_for_path (file_path);
				_tmp16_ = _tmp15_;
				beat_box_file_operator_get_music_files (self, _tmp16_, songs, not_imported);
				_g_object_unref0 (_tmp16_);
			}
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally25;
	__catch25_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not get music: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally25:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (file_info);
}


/** rescans the music folder to update the db to the folder situation.
 * If song is in folder, and in db, re-add
 * If song is not in folder and in db,remove
 * If song is in both, do nothing.
 * @param music_folder The folder to rescan
 * @param current_song_paths Paths of files already in db. once file
 * is re-added, set string to "ADDED". at end, remove all songs that
 * are not re-added.
 * @return file paths of songs no longer available. TODO: should out that
 */
void beat_box_file_operator_rescan_music (BeatBoxFileOperator* self, GFile* music_folder, GeeLinkedList** current_song_paths, GeeLinkedList** not_imported, GeeLinkedList** new_songs) {
	GFileInfo* file_info;
	gint songs_added;
	GFileEnumerator* _tmp0_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (music_folder != NULL);
	g_return_if_fail (current_song_paths != NULL);
	g_return_if_fail (not_imported != NULL);
	g_return_if_fail (new_songs != NULL);
	file_info = NULL;
	songs_added = 0;
	_tmp0_ = g_file_enumerate_children (music_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch26_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp1_ = NULL;
		GFileInfo* _tmp2_;
		GFileInfo* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* file_path;
		gboolean _tmp9_ = FALSE;
		GFileType _tmp10_;
		_tmp1_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch26_g_error;
		}
		_tmp3_ = _tmp2_;
		_g_object_unref0 (file_info);
		file_info = _tmp3_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp4_ = g_file_get_path (music_folder);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_strconcat (_tmp5_, "/", NULL);
		_tmp7_ = g_file_info_get_name (file_info);
		file_path = (_tmp8_ = g_strconcat (_tmp6_, _tmp7_, NULL), _g_free0 (_tmp6_), _g_free0 (_tmp5_), _tmp8_);
		g_signal_emit_by_name (self, "fo-progress", NULL, ((gdouble) ((gdouble) self->priv->index)) / ((gdouble) self->priv->item_count));
		_tmp10_ = g_file_info_get_file_type (file_info);
		if (_tmp10_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp11_ = NULL;
			gboolean _tmp12_;
			_tmp11_ = g_file_info_get_name (file_info);
			_tmp12_ = beat_box_file_operator_is_valid_file_type (self, _tmp11_);
			_tmp9_ = _tmp12_;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			gboolean _tmp13_;
			_tmp13_ = gee_abstract_collection_contains ((GeeAbstractCollection*) (*current_song_paths), file_path);
			if (_tmp13_) {
				gee_abstract_collection_remove ((GeeAbstractCollection*) (*current_song_paths), file_path);
				self->priv->index = self->priv->index + 1;
			} else {
				gboolean _tmp14_;
				_tmp14_ = gee_abstract_collection_contains ((GeeAbstractCollection*) (*current_song_paths), file_path);
				if (!_tmp14_) {
					BeatBoxSong* _tmp15_ = NULL;
					BeatBoxSong* s;
					_tmp15_ = beat_box_file_operator_import_song (self, file_path);
					s = _tmp15_;
					if (s != NULL) {
						beat_box_library_manager_add_song (self->priv->lm, s);
						gee_abstract_collection_add ((GeeAbstractCollection*) (*new_songs), s);
					} else {
						gee_abstract_collection_add ((GeeAbstractCollection*) (*not_imported), file_path);
					}
					songs_added = songs_added + 1;
					_g_object_unref0 (s);
				}
			}
		} else {
			GFileType _tmp16_;
			_tmp16_ = g_file_info_get_file_type (file_info);
			if (_tmp16_ == G_FILE_TYPE_DIRECTORY) {
				GFile* _tmp17_ = NULL;
				GFile* _tmp18_;
				_tmp17_ = g_file_new_for_path (file_path);
				_tmp18_ = _tmp17_;
				beat_box_file_operator_rescan_music (self, _tmp18_, current_song_paths, not_imported, new_songs);
				_g_object_unref0 (_tmp18_);
			}
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally26;
	__catch26_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not rescan music folder: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally26:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (file_info);
}


BeatBoxSong* beat_box_file_operator_import_song (BeatBoxFileOperator* self, const gchar* file_path) {
	BeatBoxSong* result = NULL;
	BeatBoxSong* _tmp0_ = NULL;
	BeatBoxSong* s;
	TagLib_File* tag_file = NULL;
	TagLib_File* _tmp1_ = NULL;
	TagLib_File* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (file_path != NULL, NULL);
	_tmp0_ = beat_box_song_new (file_path);
	s = _tmp0_;
	_tmp1_ = taglib_file_new (file_path);
	_tmp2_ = _tmp1_;
	_taglib_file_free0 (tag_file);
	tag_file = _tmp2_;
	if (tag_file != NULL) {
		TagLib_Tag* _tmp5_ = NULL;
		_tmp5_ = taglib_file_tag (tag_file);
		_tmp4_ = _tmp5_ != NULL;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		const TagLib_AudioProperties* _tmp6_ = NULL;
		_tmp6_ = taglib_file_audioproperties (tag_file);
		_tmp3_ = _tmp6_ != NULL;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		TagLib_Tag* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		TagLib_Tag* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		TagLib_Tag* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		TagLib_Tag* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		TagLib_Tag* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		TagLib_Tag* _tmp17_ = NULL;
		guint _tmp18_;
		TagLib_Tag* _tmp19_ = NULL;
		guint _tmp20_;
		const TagLib_AudioProperties* _tmp21_ = NULL;
		gint _tmp22_;
		const TagLib_AudioProperties* _tmp23_ = NULL;
		gint _tmp24_;
		const TagLib_AudioProperties* _tmp25_ = NULL;
		gint _tmp26_;
		time_t _tmp27_;
		gboolean _tmp28_ = FALSE;
		const gchar* _tmp29_ = NULL;
		gboolean _tmp31_ = FALSE;
		const gchar* _tmp32_ = NULL;
		_tmp7_ = taglib_file_tag (tag_file);
		_tmp8_ = taglib_tag_title (_tmp7_);
		beat_box_song_set_title (s, _tmp8_);
		_tmp9_ = taglib_file_tag (tag_file);
		_tmp10_ = taglib_tag_artist (_tmp9_);
		beat_box_song_set_artist (s, _tmp10_);
		_tmp11_ = taglib_file_tag (tag_file);
		_tmp12_ = taglib_tag_album (_tmp11_);
		beat_box_song_set_album (s, _tmp12_);
		_tmp13_ = taglib_file_tag (tag_file);
		_tmp14_ = taglib_tag_genre (_tmp13_);
		beat_box_song_set_genre (s, _tmp14_);
		_tmp15_ = taglib_file_tag (tag_file);
		_tmp16_ = taglib_tag_comment (_tmp15_);
		beat_box_song_set_comment (s, _tmp16_);
		_tmp17_ = taglib_file_tag (tag_file);
		_tmp18_ = taglib_tag_year (_tmp17_);
		beat_box_song_set_year (s, (gint) _tmp18_);
		_tmp19_ = taglib_file_tag (tag_file);
		_tmp20_ = taglib_tag_track (_tmp19_);
		beat_box_song_set_track (s, (gint) _tmp20_);
		_tmp21_ = taglib_file_audioproperties (tag_file);
		_tmp22_ = taglib_audioproperties_bitrate (_tmp21_);
		beat_box_song_set_bitrate (s, _tmp22_);
		_tmp23_ = taglib_file_audioproperties (tag_file);
		_tmp24_ = taglib_audioproperties_length (_tmp23_);
		beat_box_song_set_length (s, _tmp24_);
		_tmp25_ = taglib_file_audioproperties (tag_file);
		_tmp26_ = taglib_audioproperties_samplerate (_tmp25_);
		beat_box_song_set_samplerate (s, _tmp26_);
		_tmp27_ = time (NULL);
		beat_box_song_set_date_added (s, (gint) _tmp27_);
		__finally27:
		_tmp29_ = beat_box_song_get_title (s);
		if (_tmp29_ == NULL) {
			_tmp28_ = TRUE;
		} else {
			const gchar* _tmp30_ = NULL;
			_tmp30_ = beat_box_song_get_title (s);
			_tmp28_ = g_strcmp0 (_tmp30_, "") == 0;
		}
		if (_tmp28_) {
			beat_box_song_set_title (s, "Unkown");
		}
		_tmp32_ = beat_box_song_get_artist (s);
		if (_tmp32_ == NULL) {
			_tmp31_ = TRUE;
		} else {
			const gchar* _tmp33_ = NULL;
			_tmp33_ = beat_box_song_get_artist (s);
			_tmp31_ = g_strcmp0 (_tmp33_, "") == 0;
		}
		if (_tmp31_) {
			beat_box_song_set_artist (s, "Unkown");
		}
		if (_inner_error_ != NULL) {
			_taglib_file_free0 (tag_file);
			_g_object_unref0 (s);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	} else {
		result = NULL;
		_taglib_file_free0 (tag_file);
		_g_object_unref0 (s);
		return result;
	}
	result = s;
	_taglib_file_free0 (tag_file);
	return result;
}


static gboolean beat_box_file_operator_is_image_file_type (BeatBoxFileOperator* self, const gchar* type) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (type != NULL, FALSE);
	_tmp1_ = g_str_has_suffix (type, ".jpg");
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp2_;
		_tmp2_ = g_str_has_suffix (type, ".png");
		_tmp0_ = _tmp2_;
	}
	result = _tmp0_;
	return result;
}


static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


gchar* beat_box_file_operator_get_folder (const gchar* file) {
	gchar* result = NULL;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** paths;
	gint paths_length1;
	gint _paths_size_;
	gboolean _tmp2_;
	gchar* _tmp4_;
	gchar* folder_string;
	g_return_val_if_fail (file != NULL, NULL);
	_tmp1_ = _tmp0_ = g_strsplit (file, "/", 0);
	paths = _tmp1_;
	paths_length1 = _vala_array_length (_tmp0_);
	_paths_size_ = _vala_array_length (_tmp0_);
	_tmp2_ = g_str_has_suffix (file, "/");
	if (!_tmp2_) {
		gchar* _tmp3_;
		_tmp3_ = g_strdup (" ");
		_vala_array_add1 (&paths, &paths_length1, &_paths_size_, _tmp3_);
	}
	_tmp4_ = g_strdup ("");
	folder_string = _tmp4_;
	{
		gint index;
		index = 0;
		{
			gboolean _tmp5_;
			_tmp5_ = TRUE;
			while (TRUE) {
				gchar* _tmp6_;
				gchar* _tmp7_;
				if (!_tmp5_) {
					index = index + 1;
				}
				_tmp5_ = FALSE;
				if (!(index < (paths_length1 - 2))) {
					break;
				}
				_tmp6_ = g_strconcat (paths[index], "/", NULL);
				_tmp7_ = g_strconcat (folder_string, _tmp6_, NULL);
				_g_free0 (folder_string);
				folder_string = _tmp7_;
				_g_free0 (_tmp6_);
			}
		}
	}
	result = folder_string;
	paths = (_vala_array_free (paths, paths_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


gchar* beat_box_file_operator_find_album (BeatBoxFileOperator* self, BeatBoxSong* s) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* album_folder_string;
	GFile* _tmp2_ = NULL;
	GFile* album_folder;
	GFileInfo* file_info;
	GFileEnumerator* _tmp3_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	_tmp0_ = beat_box_song_get_file (s);
	_tmp1_ = beat_box_file_operator_get_folder (_tmp0_);
	album_folder_string = _tmp1_;
	_tmp2_ = g_file_new_for_path (album_folder_string);
	album_folder = _tmp2_;
	file_info = NULL;
	_tmp3_ = g_file_enumerate_children (album_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp3_;
	if (_inner_error_ != NULL) {
		goto __catch28_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp4_ = NULL;
		GFileInfo* _tmp5_;
		GFileInfo* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gchar* _tmp9_;
		const gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		gchar* file_path;
		gboolean _tmp12_ = FALSE;
		gboolean _tmp13_ = FALSE;
		GFileType _tmp14_;
		_tmp4_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp5_ = _tmp4_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch28_g_error;
		}
		_tmp6_ = _tmp5_;
		_g_object_unref0 (file_info);
		file_info = _tmp6_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp7_ = g_file_get_path (album_folder);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_strconcat (_tmp8_, "/", NULL);
		_tmp10_ = g_file_info_get_name (file_info);
		file_path = (_tmp11_ = g_strconcat (_tmp9_, _tmp10_, NULL), _g_free0 (_tmp9_), _g_free0 (_tmp8_), _tmp11_);
		_tmp14_ = g_file_info_get_file_type (file_info);
		if (_tmp14_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp15_ = NULL;
			gboolean _tmp16_;
			_tmp15_ = g_file_info_get_name (file_info);
			_tmp16_ = beat_box_file_operator_is_image_file_type (self, _tmp15_);
			_tmp13_ = _tmp16_;
		} else {
			_tmp13_ = FALSE;
		}
		if (_tmp13_) {
			const gchar* _tmp17_ = NULL;
			const gchar* _tmp18_ = NULL;
			gboolean _tmp19_;
			_tmp17_ = g_file_info_get_name (file_info);
			_tmp18_ = beat_box_song_get_album (s);
			_tmp19_ = string_contains (_tmp17_, _tmp18_);
			_tmp12_ = _tmp19_;
		} else {
			_tmp12_ = FALSE;
		}
		if (_tmp12_) {
			result = file_path;
			_g_object_unref0 (enumerator);
			_g_object_unref0 (file_info);
			_g_object_unref0 (album_folder);
			_g_free0 (album_folder_string);
			return result;
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally28;
	__catch28_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not find album artwork: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally28:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		_g_object_unref0 (album_folder);
		_g_free0 (album_folder_string);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	_g_object_unref0 (file_info);
	_g_object_unref0 (album_folder);
	_g_free0 (album_folder_string);
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GRegex* _tmp2_ = NULL;
	GRegex* _tmp3_;
	GRegex* regex;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	_tmp0_ = g_regex_escape_string (old, -1);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_regex_new (_tmp1_, 0, 0, &_inner_error_);
	regex = (_tmp3_ = _tmp2_, _g_free0 (_tmp1_), _tmp3_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_REGEX_ERROR) {
			goto __catch30_g_regex_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp4_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
	_tmp5_ = _tmp4_;
	if (_inner_error_ != NULL) {
		_g_regex_unref0 (regex);
		if (_inner_error_->domain == G_REGEX_ERROR) {
			goto __catch30_g_regex_error;
		}
		_g_regex_unref0 (regex);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = _tmp5_;
	_g_regex_unref0 (regex);
	return result;
	_g_regex_unref0 (regex);
	goto __finally30;
	__catch30_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally30:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


GdkPixbuf* beat_box_file_operator_save_album (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* rv = NULL;
	gboolean _tmp0_ = FALSE;
	GFile* _tmp1_ = NULL;
	GFile* file;
	GFileInputStream* filestream = NULL;
	GFileInputStream* _tmp2_ = NULL;
	GFileInputStream* _tmp3_;
	GFileInputStream* _tmp4_;
	GdkPixbuf* _tmp5_ = NULL;
	GdkPixbuf* _tmp6_;
	GdkPixbuf* _tmp7_;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_;
	const gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	if (uri == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (uri, "") == 0;
	}
	if (_tmp0_) {
		result = NULL;
		_g_object_unref0 (rv);
		return result;
	}
	_tmp1_ = g_file_new_for_uri (uri);
	file = _tmp1_;
	if (file == NULL) {
		fprintf (stdout, "Could not access %s\n", uri);
		result = NULL;
		_g_object_unref0 (file);
		_g_object_unref0 (rv);
		return result;
	}
	_tmp2_ = g_file_read (file, NULL, &_inner_error_);
	_tmp3_ = _tmp2_;
	if (_inner_error_ != NULL) {
		goto __catch29_g_error;
	}
	_tmp4_ = _tmp3_;
	_g_object_unref0 (filestream);
	filestream = _tmp4_;
	_tmp5_ = gdk_pixbuf_new_from_stream ((GInputStream*) filestream, NULL, &_inner_error_);
	_tmp6_ = _tmp5_;
	if (_inner_error_ != NULL) {
		goto __catch29_g_error;
	}
	_tmp7_ = _tmp6_;
	_g_object_unref0 (rv);
	rv = _tmp7_;
	_tmp8_ = beat_box_song_get_file (s);
	_tmp9_ = beat_box_file_operator_get_folder (_tmp8_);
	_tmp10_ = _tmp9_;
	fprintf (stdout, "Saving to %s\n", _tmp10_);
	_g_free0 (_tmp10_);
	_tmp11_ = beat_box_song_get_file (s);
	_tmp12_ = beat_box_file_operator_get_folder (_tmp11_);
	_tmp13_ = _tmp12_;
	_tmp14_ = beat_box_song_get_album (s);
	_tmp15_ = string_replace (_tmp14_, "/", "_");
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strconcat (_tmp13_, _tmp16_, NULL);
	_tmp18_ = g_strconcat (_tmp17_, ".jpg", NULL);
	gdk_pixbuf_save (rv, _tmp18_, "jpeg", &_inner_error_, NULL);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp17_);
	_g_free0 (_tmp16_);
	_g_free0 (_tmp13_);
	if (_inner_error_ != NULL) {
		goto __catch29_g_error;
	}
	goto __finally29;
	__catch29_g_error:
	{
		GError * err;
		GdkPixbuf* _tmp19_;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not save album art from %s: %s\n", uri, err->message);
		_tmp19_ = NULL;
		_g_object_unref0 (rv);
		rv = _tmp19_;
		_g_error_free0 (err);
	}
	__finally29:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (filestream);
		_g_object_unref0 (file);
		_g_object_unref0 (rv);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = rv;
	_g_object_unref0 (filestream);
	_g_object_unref0 (file);
	return result;
}


gchar* beat_box_file_operator_find_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* artist_folder_string;
	GFile* _tmp5_ = NULL;
	GFile* artist_folder;
	GFileInfo* file_info;
	GFileEnumerator* _tmp6_ = NULL;
	GFileEnumerator* enumerator;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	_tmp0_ = beat_box_song_get_file (s);
	_tmp1_ = beat_box_file_operator_get_folder (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = beat_box_file_operator_get_folder (_tmp2_);
	artist_folder_string = (_tmp4_ = _tmp3_, _g_free0 (_tmp2_), _tmp4_);
	_tmp5_ = g_file_new_for_path (artist_folder_string);
	artist_folder = _tmp5_;
	file_info = NULL;
	_tmp6_ = g_file_enumerate_children (artist_folder, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, NULL, &_inner_error_);
	enumerator = _tmp6_;
	if (_inner_error_ != NULL) {
		goto __catch31_g_error;
	}
	while (TRUE) {
		GFileInfo* _tmp7_ = NULL;
		GFileInfo* _tmp8_;
		GFileInfo* _tmp9_;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		gchar* _tmp12_;
		const gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		gchar* file_path;
		gboolean _tmp15_ = FALSE;
		GFileType _tmp16_;
		_tmp7_ = g_file_enumerator_next_file (enumerator, NULL, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (enumerator);
			goto __catch31_g_error;
		}
		_tmp9_ = _tmp8_;
		_g_object_unref0 (file_info);
		file_info = _tmp9_;
		if (!(file_info != NULL)) {
			break;
		}
		_tmp10_ = g_file_get_path (artist_folder);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strconcat (_tmp11_, "/", NULL);
		_tmp13_ = g_file_info_get_name (file_info);
		file_path = (_tmp14_ = g_strconcat (_tmp12_, _tmp13_, NULL), _g_free0 (_tmp12_), _g_free0 (_tmp11_), _tmp14_);
		_tmp16_ = g_file_info_get_file_type (file_info);
		if (_tmp16_ == G_FILE_TYPE_REGULAR) {
			const gchar* _tmp17_ = NULL;
			gboolean _tmp18_;
			_tmp17_ = g_file_info_get_name (file_info);
			_tmp18_ = beat_box_file_operator_is_image_file_type (self, _tmp17_);
			_tmp15_ = _tmp18_;
		} else {
			_tmp15_ = FALSE;
		}
		if (_tmp15_) {
			result = file_path;
			_g_object_unref0 (enumerator);
			_g_object_unref0 (file_info);
			_g_object_unref0 (artist_folder);
			_g_free0 (artist_folder_string);
			return result;
		}
		_g_free0 (file_path);
	}
	_g_object_unref0 (enumerator);
	goto __finally31;
	__catch31_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not find artist image: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally31:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file_info);
		_g_object_unref0 (artist_folder);
		_g_free0 (artist_folder_string);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	_g_object_unref0 (file_info);
	_g_object_unref0 (artist_folder);
	_g_free0 (artist_folder_string);
	return result;
}


GdkPixbuf* beat_box_file_operator_save_artist_image (BeatBoxFileOperator* self, BeatBoxSong* s, const gchar* uri) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* rv = NULL;
	gboolean _tmp0_ = FALSE;
	GFile* _tmp1_ = NULL;
	GFile* file;
	GFileInputStream* filestream = NULL;
	GFileInputStream* _tmp2_ = NULL;
	GFileInputStream* _tmp3_;
	GFileInputStream* _tmp4_;
	GdkPixbuf* _tmp5_ = NULL;
	GdkPixbuf* _tmp6_;
	GdkPixbuf* _tmp7_;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	const gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	gchar* _tmp15_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	if (uri == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (uri, "") == 0;
	}
	if (_tmp0_) {
		result = NULL;
		_g_object_unref0 (rv);
		return result;
	}
	_tmp1_ = g_file_new_for_uri (uri);
	file = _tmp1_;
	_tmp2_ = g_file_read (file, NULL, &_inner_error_);
	_tmp3_ = _tmp2_;
	if (_inner_error_ != NULL) {
		goto __catch32_g_error;
	}
	_tmp4_ = _tmp3_;
	_g_object_unref0 (filestream);
	filestream = _tmp4_;
	_tmp5_ = gdk_pixbuf_new_from_stream ((GInputStream*) filestream, NULL, &_inner_error_);
	_tmp6_ = _tmp5_;
	if (_inner_error_ != NULL) {
		goto __catch32_g_error;
	}
	_tmp7_ = _tmp6_;
	_g_object_unref0 (rv);
	rv = _tmp7_;
	_tmp8_ = beat_box_song_get_file (s);
	_tmp9_ = beat_box_file_operator_get_folder (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = beat_box_file_operator_get_folder (_tmp10_);
	_tmp12_ = _tmp11_;
	_tmp13_ = beat_box_song_get_artist (s);
	_tmp14_ = g_strconcat (_tmp12_, _tmp13_, NULL);
	_tmp15_ = g_strconcat (_tmp14_, ".jpg", NULL);
	gdk_pixbuf_save (rv, _tmp15_, "jpeg", &_inner_error_, NULL);
	_g_free0 (_tmp15_);
	_g_free0 (_tmp14_);
	_g_free0 (_tmp12_);
	_g_free0 (_tmp10_);
	if (_inner_error_ != NULL) {
		goto __catch32_g_error;
	}
	goto __finally32;
	__catch32_g_error:
	{
		GError * err;
		GdkPixbuf* _tmp16_;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not save artist image from %s: %s\n", uri, err->message);
		_tmp16_ = NULL;
		_g_object_unref0 (rv);
		rv = _tmp16_;
		_g_error_free0 (err);
	}
	__finally32:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (filestream);
		_g_object_unref0 (file);
		_g_object_unref0 (rv);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = rv;
	_g_object_unref0 (filestream);
	_g_object_unref0 (file);
	return result;
}


static gpointer _beat_box_file_operator_save_song_thread_gthread_func (gpointer self) {
	gpointer result;
	result = beat_box_file_operator_save_song_thread (self);
	return result;
}


void beat_box_file_operator_save_song (BeatBoxFileOperator* self, BeatBoxSong* s) {
	BeatBoxSong* _tmp0_;
	BeatBoxSong* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (s != NULL);
	_tmp0_ = _g_object_ref0 (s);
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->temp_song);
	self->priv->temp_song = _tmp1_;
	g_thread_create (_beat_box_file_operator_save_song_thread_gthread_func, self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		goto __catch33_g_error;
	}
	goto __finally33;
	__catch33_g_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Could not create thread to rescan music folder: %s\n", err->message);
		_g_error_free0 (err);
	}
	__finally33:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void* beat_box_file_operator_save_song_thread (BeatBoxFileOperator* self) {
	void* result = NULL;
	TagLib_File* tag_file = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	TagLib_File* _tmp2_ = NULL;
	TagLib_File* _tmp3_;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = beat_box_song_get_file (self->priv->temp_song);
	fprintf (stdout, "Saving file %s \n", _tmp0_);
	_tmp1_ = beat_box_song_get_file (self->priv->temp_song);
	_tmp2_ = taglib_file_new (_tmp1_);
	_tmp3_ = _tmp2_;
	_taglib_file_free0 (tag_file);
	tag_file = _tmp3_;
	if (tag_file != NULL) {
		TagLib_Tag* _tmp6_ = NULL;
		_tmp6_ = taglib_file_tag (tag_file);
		_tmp5_ = _tmp6_ != NULL;
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		const TagLib_AudioProperties* _tmp7_ = NULL;
		_tmp7_ = taglib_file_audioproperties (tag_file);
		_tmp4_ = _tmp7_ != NULL;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		TagLib_Tag* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		TagLib_Tag* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		TagLib_Tag* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		TagLib_Tag* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		TagLib_Tag* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		TagLib_Tag* _tmp18_ = NULL;
		gint _tmp19_;
		TagLib_Tag* _tmp20_ = NULL;
		gint _tmp21_;
		_tmp8_ = taglib_file_tag (tag_file);
		_tmp9_ = beat_box_song_get_title (self->priv->temp_song);
		taglib_tag_set_title (_tmp8_, _tmp9_);
		_tmp10_ = taglib_file_tag (tag_file);
		_tmp11_ = beat_box_song_get_artist (self->priv->temp_song);
		taglib_tag_set_artist (_tmp10_, _tmp11_);
		_tmp12_ = taglib_file_tag (tag_file);
		_tmp13_ = beat_box_song_get_album (self->priv->temp_song);
		taglib_tag_set_album (_tmp12_, _tmp13_);
		_tmp14_ = taglib_file_tag (tag_file);
		_tmp15_ = beat_box_song_get_genre (self->priv->temp_song);
		taglib_tag_set_genre (_tmp14_, _tmp15_);
		_tmp16_ = taglib_file_tag (tag_file);
		_tmp17_ = beat_box_song_get_comment (self->priv->temp_song);
		taglib_tag_set_comment (_tmp16_, _tmp17_);
		_tmp18_ = taglib_file_tag (tag_file);
		_tmp19_ = beat_box_song_get_year (self->priv->temp_song);
		taglib_tag_set_year (_tmp18_, (guint) _tmp19_);
		_tmp20_ = taglib_file_tag (tag_file);
		_tmp21_ = beat_box_song_get_track (self->priv->temp_song);
		taglib_tag_set_track (_tmp20_, (guint) _tmp21_);
		taglib_file_save (tag_file);
		__finally34:
		if (_inner_error_ != NULL) {
			_taglib_file_free0 (tag_file);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	} else {
		const gchar* _tmp22_ = NULL;
		_tmp22_ = beat_box_song_get_file (self->priv->temp_song);
		fprintf (stdout, "Could not save %s.\n", _tmp22_);
	}
	result = NULL;
	_taglib_file_free0 (tag_file);
	return result;
}


void beat_box_file_operator_update_file_hierarchy (BeatBoxFileOperator* self, BeatBoxSong* s) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (s != NULL);
	fprintf (stdout, "TODO: Actually update file hierarchy based on artist and album\n");
}


static void g_cclosure_user_marshal_VOID__STRING_DOUBLE (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_DOUBLE) (gpointer data1, const char* arg_1, gdouble arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_DOUBLE callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_DOUBLE) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_double (param_values + 2), data2);
}


static void beat_box_file_operator_class_init (BeatBoxFileOperatorClass * klass) {
	beat_box_file_operator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BeatBoxFileOperatorPrivate));
	G_OBJECT_CLASS (klass)->finalize = beat_box_file_operator_finalize;
	g_signal_new ("fo_progress", BEAT_BOX_TYPE_FILE_OPERATOR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_DOUBLE, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_DOUBLE);
}


static void beat_box_file_operator_instance_init (BeatBoxFileOperator * self) {
	self->priv = BEAT_BOX_FILE_OPERATOR_GET_PRIVATE (self);
}


static void beat_box_file_operator_finalize (GObject* obj) {
	BeatBoxFileOperator * self;
	self = BEAT_BOX_FILE_OPERATOR (obj);
	_g_object_unref0 (self->priv->lm);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->temp_song);
	G_OBJECT_CLASS (beat_box_file_operator_parent_class)->finalize (obj);
}


GType beat_box_file_operator_get_type (void) {
	static volatile gsize beat_box_file_operator_type_id__volatile = 0;
	if (g_once_init_enter (&beat_box_file_operator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BeatBoxFileOperatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beat_box_file_operator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BeatBoxFileOperator), 0, (GInstanceInitFunc) beat_box_file_operator_instance_init, NULL };
		GType beat_box_file_operator_type_id;
		beat_box_file_operator_type_id = g_type_register_static (G_TYPE_OBJECT, "BeatBoxFileOperator", &g_define_type_info, 0);
		g_once_init_leave (&beat_box_file_operator_type_id__volatile, beat_box_file_operator_type_id);
	}
	return beat_box_file_operator_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



